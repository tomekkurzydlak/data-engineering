pub async fn run_synchronized_dynamic(
    &self,
    files: Vec<FileProcess>,
) -> Result<()> {

    // Każdy plik ma swój "last_seq"
    let mut last_seq: HashMap<String, u32> = HashMap::new();
    for f in &files {
        last_seq.insert(f.file_id.clone(), 0);
    }

    loop {
        let mut batch: Vec<(String, String, ProcessStep)> = vec![];

        // 1) Pobieramy następne kroki dla każdego pliku
        for f in &files {
            let file_id = &f.file_id;
            let step_opt = self.get_steps_for_file(file_id).await?;

            if let Some(step) = step_opt {
                batch.push((
                    f.file_id.clone(),
                    f.gcs_file_uri.clone(),
                    step.clone(),
                ));
            }
        }

        // 2) Jeżeli nie ma żadnych nowych kroków — KONIEC PIPELINE
        if batch.is_empty() {
            info!("DYNAMIC-SYNC: brak kolejnych kroków → pipeline zakończony");
            break;
        }

        // 3) Odpalamy WSZYSTKIE kroki synchroniczne
        let mut handles = vec![];

        for (file_id, gcs_uri, step) in batch {
            let backend = Arc::clone(&self.backend);
            let envs = self.cfg.env_vars.clone();

            // każdy krok wykonuje się jako task Tokio
            let h = tokio::spawn(async move {
                let payload = json!({
                    "file_id": file_id,
                    "gcs_file_uri": gcs_uri,
                    "seq": step.exec_process_seq,
                    "process_cd": step.process_cd,
                });

                let cloudrun = backend.as_any().downcast_ref::<CloudRunBackend>();

                let exec_id = if let Some(cr) = cloudrun {
                    cr.start_job(&step.exec_object_nm, &payload, &envs).await?
                } else {
                    backend.dispatch_job(&step.exec_object_nm, &payload).await?
                };

                if let Some(cr) = cloudrun {
                    cr.poll_until_done(
                        &exec_id,
                        Duration::from_secs(600),
                        Duration::from_secs(5),
                    ).await?;
                }

                Ok::<(), anyhow::Error>(())
            });

            handles.push(h);
        }

        // 4) czekamy aż WSZYSTKIE zakończą się
        for h in handles {
            h.await??;
        }

        // 5) aktualizacja "last_seq"
        for f in &files {
            if let Some(s) = last_seq.get_mut(&f.file_id) {
                *s += 1;
            }
        }
    }

    Ok(())
}
