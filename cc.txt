use anyhow::{Context, Result};
use async_trait::async_trait;
use gcp_auth::{provider, TokenProvider};
use reqwest::Client;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::time::Duration;
use tokio::time::sleep;
use tracing::{debug, error, info, warn};
use std::sync::Arc;


use crate::backend::ProcessorBackend;

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct ExecutionStatus {
    pub name: String,
    pub uid: Option<String>,
    pub create_time: Option<String>,
    pub update_time: Option<String>,
    pub state: Option<String>,
    pub task_count: Option<u32>,
    pub succeeded_count: Option<u32>,
    pub failed_count: Option<u32>,
    pub cancelled_count: Option<u32>,
}

pub struct CloudRunBackend {
    pub project: String,
    pub region: String,
    client: Client,
    token_provider: Arc<dyn TokenProvider + Send + Sync>,
}

impl CloudRunBackend {
    pub async fn new(project: String, region: String) -> Result<Self> {
        // provider() już zwraca Arc<dyn TokenProvider>
        let provider = gcp_auth::provider().await?;
        let client = Client::builder().build()?;

        Ok(Self {
            project,
            region,
            client,
            token_provider: provider, // ✅ bez Box::new()
        })
    }

    async fn get_token(&self) -> Result<String> {
        let scopes = &["https://www.googleapis.com/auth/cloud-platform"];
        let token = self.token_provider.token(scopes).await?;
        Ok(token.as_str().to_string())
    }

    fn jobs_base(&self) -> String {
        format!(
            "https://run.googleapis.com/v2/projects/{}/locations/{}",
            self.project, self.region
        )
    }

    async fn start_job(&self, job_name: &str, json_payload: &Value) -> Result<String> {
        let token = self.get_token().await?;
        let url = format!("{}/jobs/{}:run", self.jobs_base(), job_name);

        info!(%job_name, "Wywołuję Cloud Run Job...");
        let body = serde_json::json!({
            "overrides": {
                "containerOverrides": [{
                    "args": [ serde_json::to_string(json_payload)? ]
                }]
            }
        });

        let res = self.client
            .post(&url)
            .bearer_auth(&token)
            .json(&body)
            .send()
            .await
            .context("błąd HTTP POST /run")?;

        if !res.status().is_success() {
            let status = res.status();
            let txt = res.text().await.unwrap_or_default();
            anyhow::bail!("Job execution HTTP error {}: {}", status, txt);
        }

        let body: Value = res.json().await?;
        let exec_id = body["name"]
            .as_str()
            .unwrap_or("unknown-exec-id")
            .to_string();

        info!(%exec_id, %job_name, "Cloud Run Job wystartował");
        Ok(exec_id)
    }

    pub async fn get_execution_status(&self, exec_name: &str) -> Result<ExecutionStatus> {
        let token = self.get_token().await?;
        let url = format!("https://run.googleapis.com/v2/{}", exec_name);

        let res = self.client
            .get(&url)
            .bearer_auth(&token)
            .send()
            .await
            .context("błąd GET execution")?;

        if !res.status().is_success() {
            let status = res.status();
            let txt = res.text().await.unwrap_or_default();
            anyhow::bail!("GET execution HTTP error {}: {}", status, txt);
        }

        let status: ExecutionStatus = res.json().await?;
        Ok(status)
    }

    pub async fn poll_until_done(
        &self,
        exec_name: &str,
        max_wait: Duration,
        interval: Duration,
    ) -> Result<String> {
        let start = std::time::Instant::now();
        sleep(Duration::from_secs(5)).await;

        loop {
            let status = self.get_execution_status(exec_name).await?;
            let state = status.state.clone().unwrap_or_else(|| "UNKNOWN".to_string());
            debug!(%exec_name, %state, "Execution status poll");

            match state.as_str() {
                "SUCCEEDED" => {
                    info!(%exec_name, "Execution SUCCEEDED");
                    return Ok(state);
                }
                "FAILED" | "CANCELLED" => {
                    error!(%exec_name, "Execution FAILED");
                    anyhow::bail!("Execution {} failed ({})", exec_name, state)
                }
                "RUNNING" | "QUEUED" => {
                    if start.elapsed() > max_wait {
                        error!(%exec_name, "Execution TIMED OUT");
                        anyhow::bail!("Execution {} timed out", exec_name)
                    }
                    sleep(interval).await;
                }
                _ => {
                    warn!(%exec_name, %state, "Execution w stanie nieznanym, kontynuuję polling...");
                    sleep(interval).await;
                }
            }
        }
    }
}

#[async_trait]
impl ProcessorBackend for CloudRunBackend {
    async fn dispatch_job(&self, job_name: &str, json_payload: &Value) -> Result<String> {
        self.start_job(job_name, json_payload).await
    }

    async fn ping(&self, job_name: &str) -> Result<()> {
        let token = self.get_token().await?;
        let url = format!("{}/jobs/{}", self.jobs_base(), job_name);
        let res = self.client
            .get(&url)
            .bearer_auth(&token)
            .send()
            .await
            .context("błąd GET job")?;

        if res.status().is_success() {
            info!(%job_name, "Job OK (ping)");
            Ok(())
        } else {
            warn!(%job_name, status=%res.status(), "Ping nie powiódł się");
            anyhow::bail!("Ping failed {}", res.status())
        }
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}
