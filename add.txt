fn render_block_lines_to_md(lines: &[LineBox]) -> String {
    if lines.is_empty() {
        return String::new();
    }

    // --- progi (stroić na realnych PDF-ach) ---
    let paragraph_gap: f32 = 10.0;

    // listy
    let indent_step_px: f32 = 22.0;            // szerokość "stopnia" wcięcia listy
    let continuation_gap_px: f32 = 10.0;       // max przerwa pionowa dla zawijania itemu
    let continuation_indent_px: f32 = 18.0;    // tolerancja X dla kontynuacji itemu

    // --- body_left: lokalnie dla bloku ---
    let mut body_left = f32::INFINITY;
    for l in lines {
        let t = line_to_text(l);
        if t.len() >= 20 {
            body_left = body_left.min(l.x_min);
        }
    }
    if !body_left.is_finite() {
        body_left = lines.first().map(|l| l.x_min).unwrap_or(0.0);
    }

    // --- body_width: mediana szerokości "typowych" linii ---
    let mut widths: Vec<f32> = lines
        .iter()
        .map(|l| (l.x_max - body_left).max(0.0))
        .collect();
    widths.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
    let body_width = widths.get(widths.len() / 2).copied().unwrap_or(500.0);

    let mut out = String::new();

    // --- state list ---
    let mut in_list: bool = false;
    let mut list_base_content_x: f32 = 0.0; // anchor poziomu 0 (po markerze)
    let mut last_item_content_x: f32 = 0.0; // anchor treści bieżącego itemu
    let mut last_level: usize = 0;

    for i in 0..lines.len() {
        let line = &lines[i];
        let text = line_to_text(line);

        if text.is_empty() {
            continue;
        }

        let prev_gap = if i == 0 {
            999.0
        } else {
            (line.y_min - lines[i - 1].y_max).abs()
        };

        let next_gap = if i + 1 >= lines.len() {
            999.0
        } else {
            (lines[i + 1].y_min - line.y_max).abs()
        };

        // Block break = nowy akapit
        if line.block_break_before {
            if in_list {
                out.push_str("\n\n");
                in_list = false;
            } else if !out.is_empty() && !out.ends_with("\n\n") {
                out.push_str("\n\n");
            }
        }

        // --- heurystyka nagłówka ---
        // (UWAGA: jeśli PDF-y mają dużo fałszywych headingów, poluzuj/zaostrz warunki)
        let line_w = (line.x_max - line.x_min).max(0.0);
        let short_line = line_w < body_width * 0.75;
        let separated = prev_gap >= 12.0 && next_gap >= 12.0;
        let not_body_start = (line.x_min - body_left).abs() > 4.0;

        let looks_like_heading = text.len() <= 120 && short_line && (separated || not_body_start);
        if looks_like_heading {
            if in_list {
                out.push_str("\n\n");
                in_list = false;
            } else if !out.is_empty() && !out.ends_with("\n\n") {
                out.push_str("\n\n");
            }

            let level = if line_w < body_width * 0.45 { "##" } else { "###" };
            out.push_str(level);
            out.push(' ');
            out.push_str(text.trim());
            out.push_str("\n\n");
            continue;
        }

        // --- LIST ITEM START ---
        if let Some(marker) = parse_list_marker(line) {
            let item_content_x = content_x_min_after_marker(line, marker.consume_words);

            if !in_list {
                if !out.is_empty() && !out.ends_with("\n\n") {
                    out.push_str("\n\n");
                }
                in_list = true;
                list_base_content_x = item_content_x;
                last_level = 0;
            }

            let raw = ((item_content_x - list_base_content_x) / indent_step_px).round();
            let level = raw.max(0.0) as usize;

            last_level = level;
            last_item_content_x = item_content_x;

            // indent markdown dla zagnieżdżenia
            for _ in 0..level {
                out.push_str("  ");
            }

            match marker.kind {
                ListKind::Ordered => out.push_str("1. "),
                ListKind::Unordered => out.push_str("- "),
            }

            let item_text = line
                .words
                .iter()
                .skip(marker.consume_words)
                .map(|w| w.text.as_str())
                .collect::<Vec<_>>()
                .join(" ");

            out.push_str(item_text.trim());
            continue;
        }

        // --- LIST CONTINUATION (zawijanie) ---
        if in_list {
            let is_close_vertically = prev_gap < continuation_gap_px;

            // początek treści linii (pierwsze słowo)
            let content_x = line
                .words
                .first()
                .map(|w| w.x_min)
                .unwrap_or(line.x_min);

            let likely_continuation = is_close_vertically
                && content_x >= last_item_content_x - 2.0
                && content_x <= last_item_content_x + continuation_indent_px;

            if likely_continuation {
                out.push('\n');
                for _ in 0..last_level {
                    out.push_str("  ");
                }
                out.push_str("   ");
                out.push_str(text.trim());
                continue;
            }

            // jeśli nie pasuje jako kontynuacja, zamykamy listę
            out.push_str("\n\n");
            in_list = false;
        }

        // --- zwykłe akapity ---
        if out.is_empty() {
            out.push_str(text.trim());
        } else if prev_gap >= paragraph_gap {
            if !out.ends_with("\n\n") {
                out.push_str("\n\n");
            }
            out.push_str(text.trim());
        } else {
            out.push('\n');
            out.push_str(text.trim());
        }
    }

    out.trim_end().to_string()
}
