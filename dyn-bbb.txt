/// Pobiera listę plików i ich steps dla trybu batch.
/// Format z DB:
/// [
///   { "file_id": "...", "gcs_file_uri": "...", "processes": [ {...}, {...} ] },
///   { "file_id": "...", "gcs_file_uri": "...", "processes": [ {...}, {...} ] },
///   ...
/// ]
async fn get_batch_steps(
    &self,
    file_watcher_id: i64,
) -> Result<HashMap<String, (String, Vec<ProcessStep>)>> {

    let q = r#"select mda_14_proc_unstruct.get_payload_for_dispatcher_batch($1)"#;

    let row = self
        .client
        .query_one(q, &[&file_watcher_id])
        .await
        .with_context(|| {
            format!(
                "DB_FETCH_ERROR: błąd wykonania get_payload_for_dispatcher_batch({file_watcher_id})"
            )
        })?;

    // 1. Odbieramy jako serde_json::Value
    let json: JsonValue = row.get(0);

    // 2. NULL → brak batcha
    if json.is_null() {
        warn!("get_batch_steps: DB zwróciła NULL — traktuję jako brak kroków");
        return Ok(HashMap::new());
    }

    // 3. JSON musi być tablicą N elementów
    let arr = match json.as_array() {
        Some(a) if !a.is_empty() => a,
        _ => {
            warn!("get_batch_steps: JSON nie jest tablicą lub tablica jest pusta");
            return Ok(HashMap::new());
        }
    };

    // 4. Parsujemy każdy element tablicy jako FileProcess
    let mut entries: Vec<FileProcess> = Vec::new();

    for (idx, val) in arr.iter().enumerate() {
        match serde_json::from_value::<FileProcess>(val.clone()) {
            Ok(mut fp) => {
                if fp.processes.is_empty() {
                    warn!(
                        idx,
                        file_id = %fp.file_id,
                        "get_batch_steps: plik ma pustą listę processes — pomijam"
                    );
                    continue;
                }

                fp.processes.sort_by_key(|s| s.exec_process_seq);
                entries.push(fp);
            }
            Err(e) => {
                error!(
                    idx,
                    error=?e,
                    "get_batch_steps: błąd parsowania elementu tablicy — pomijam ten element"
                );
            }
        }
    }

    if entries.is_empty() {
        warn!("get_batch_steps: wszystkie elementy tablicy były puste lub błędne");
        return Ok(HashMap::new());
    }

    // 5. Budujemy mapę wynikową
    let mut map: HashMap<String, (String, Vec<ProcessStep>)> = HashMap::new();

    for e in entries {
        map.insert(e.file_id, (e.gcs_file_uri, e.processes));
    }

    Ok(map)
}
