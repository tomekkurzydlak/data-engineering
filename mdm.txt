// src/internals/md_postprocess.rs
//
// Post-processing markdown output.
// - mark_headings(): CAPS + krótkie + puste linie nad/pod -> # / ##
// - normalize_years(): skleja "rozsypane" lata
//   * poza tabelą: normalna zamiana do "YYYY r."
//   * w tabeli (między pipe '|'): zachowuje dokładnie tę samą długość komórki
// - postprocess_markdownify(): pipeline (years -> headings)

pub fn postprocess_markdownify(md: &str) -> String {
    let md = normalize_years(md);
    mark_headings(&md)
}

// ------------------------------------------------------------
// HEADINGS
// ------------------------------------------------------------

pub fn mark_headings(md: &str) -> String {
    let lines: Vec<&str> = md.lines().collect();
    let mut out: Vec<String> = Vec::with_capacity(lines.len());

    for i in 0..lines.len() {
        let line = lines[i];
        let trimmed = line.trim();

        if trimmed.is_empty() {
            out.push(String::new());
            continue;
        }

        let prev_empty = i == 0 || lines[i - 1].trim().is_empty();
        let next_empty = i + 1 >= lines.len() || lines[i + 1].trim().is_empty();

        if is_candidate_heading(trimmed) && prev_empty && next_empty {
            let level = if trimmed.len() <= 30 { "#" } else { "##" };
            out.push(format!("{} {}", level, normalize_heading(trimmed)));
        } else {
            out.push(line.to_string());
        }
    }

    out.join("\n")
}

fn is_candidate_heading(line: &str) -> bool {
    if line.len() > 50 {
        return false;
    }
    if !line.chars().any(|c| c.is_alphabetic()) {
        return false;
    }
    if line.ends_with('.') {
        return false;
    }

    let letters: Vec<char> = line.chars().filter(|c| c.is_alphabetic()).collect();
    letters.iter().all(|c| c.is_uppercase())
}

fn normalize_heading(line: &str) -> String {
    line.split_whitespace()
        .map(|w| {
            let mut chars = w.chars();
            match chars.next() {
                Some(first) => first.to_uppercase().collect::<String>() + &chars.as_str().to_lowercase(),
                None => String::new(),
            }
        })
        .collect::<Vec<_>>()
        .join(" ")
}

// ------------------------------------------------------------
// YEARS
// ------------------------------------------------------------

/// Normalizuje "rozsypane" lata do formatu "YYYY r." (poza tabelą),
/// a w tabeli (między '|') zachowuje *identyczną* długość komórki.
///
/// Przykłady (jeśli obok cyfr jest 'r' / 'r.'):
/// - "202  6 r" -> "2026 r."
/// - "202-9 r." -> "2029 r."
/// - "---203-6-- r." -> "2036 r."
/// - "--20-37--r" -> "2037 r."
///
/// Zasada tabel:
/// - w obrębie pojedynczej komórki (tekst między kolejnymi '|') po podmianie
///   długość komórki musi pozostać taka sama (żeby nie przesunąć pipe).
pub fn normalize_years(md: &str) -> String {
    let mut out = String::with_capacity(md.len());

    for line in md.split_inclusive('\n') {
        out.push_str(&normalize_years_in_line(line));
    }

    // jeśli ostatnia linia nie miała '\n'
    if !md.ends_with('\n') {
        if let Some(last) = md.lines().last() {
            // split_inclusive nie zwrócił ostatniej bez '\n' jeśli jej nie ma; ale my już ją mieliśmy w md.lines()
            // żeby nie dublować, nic nie rób — to jest tylko asekuracja, w praktyce split_inclusive ogarnia to poprawnie
            let _ = last;
        }
    }

    out
}

fn normalize_years_in_line(line: &str) -> String {
    // Heurystyka wykrycia "linii tabeli":
    // - zawiera pipe '|'
    // - i nie wygląda jak code fence
    // Nie próbujemy 100% parsera MD — tylko celujemy w typowe tabele.
    let looks_like_table = line.contains('|') && !line.trim_start().starts_with("```");

    if !looks_like_table {
        return normalize_years_free(line);
    }

    // Przetwarzamy segmenty między pipe'ami, zachowując pipe'y dokładnie.
    // Uwaga: line może zawierać '\n' (split_inclusive), więc traktujemy go jak zwykły znak.
    let mut out = String::with_capacity(line.len());
    let mut current_cell = String::new();
    let mut in_cell = false;

    for ch in line.chars() {
        if ch == '|' {
            // Flush poprzedniej komórki
            if in_cell {
                let fixed = normalize_years_cell_preserve_width(&current_cell);
                out.push_str(&fixed);
                current_cell.clear();
            }
            // Pipe zostaje
            out.push('|');
            in_cell = true;
        } else {
            if in_cell {
                current_cell.push(ch);
            } else {
                // zanim pierwszy '|' — zostawiamy jak jest
                out.push(ch);
            }
        }
    }

    // Flush ostatniej komórki (po ostatnim '|', jeśli była)
    if in_cell {
        let fixed = normalize_years_cell_preserve_width(&current_cell);
        out.push_str(&fixed);
    }

    out
}

/// Normalizacja roku w tekście "wolnym" (poza tabelą) — może zmieniać długość.
fn normalize_years_free(s: &str) -> String {
    let chars: Vec<char> = s.chars().collect();
    let mut out = String::with_capacity(s.len());
    let mut i = 0;

    while i < chars.len() {
        if !chars[i].is_ascii_digit() {
            out.push(chars[i]);
            i += 1;
            continue;
        }

        let start = i;
        let mut j = i;

        // segment = cyfry + separatory, bez liter
        while j < chars.len() {
            let c = chars[j];
            if c.is_ascii_alphanumeric() {
                if c.is_ascii_digit() {
                    j += 1;
                    continue;
                } else {
                    break; // litera kończy segment
                }
            }
            j += 1;
        }

        let segment: String = chars[start..j].iter().collect();
        let digits: String = segment.chars().filter(|c| c.is_ascii_digit()).collect();

        if digits.len() != 4 {
            out.push(chars[i]);
            i += 1;
            continue;
        }

        let year: i32 = match digits.parse() {
            Ok(y) => y,
            Err(_) => {
                out.push(chars[i]);
                i += 1;
                continue;
            }
        };

        if !(2018..=2050).contains(&year) {
            out.push(chars[i]);
            i += 1;
            continue;
        }

        // warunek "r" w max 3 znakach po ostatniej cyfrze w oryginalnym stringu
        let last_digit_pos = find_last_digit_pos(&chars, start, j).unwrap_or(j.saturating_sub(1));
        if !has_r_within_3(&chars, last_digit_pos) {
            out.push(chars[i]);
            i += 1;
            continue;
        }

        out.push_str(&format!("{} r.", year));

        // przeskocz segment + zjedz " r." / "r." / "r"
        i = j;
        i = consume_r_suffix(&chars, i, 3);

        continue;
    }

    out
}

/// Normalizuje lata w komórce tabeli, ale **zachowuje dokładnie tę samą długość komórki**.
/// To znaczy: po podmianie ilość znaków w `cell` nie zmienia się.
/// Jeśli podmiana skraca, dopadujemy spacjami.
/// Jeśli podmiana byłaby dłuższa niż fragment do podmiany — próbujemy krótszej formy, a jak się nie da, nie podmieniamy.
///
/// Uwaga: liczymy "długość" po znakach ASCII (chars). Dla typowego MD (cyfry/spacje/-/|) to jest bezpieczne.
fn normalize_years_cell_preserve_width(cell: &str) -> String {
    let chars: Vec<char> = cell.chars().collect();
    let mut out: Vec<char> = chars.clone(); // będziemy modyfikować "in place" przez nadpisywanie zakresów
    let mut i = 0;

    while i < chars.len() {
        if !chars[i].is_ascii_digit() {
            i += 1;
            continue;
        }

        let start = i;
        let mut j = i;

        // segment w komórce: cyfry + separatory, bez liter
        while j < chars.len() {
            let c = chars[j];
            if c.is_ascii_alphanumeric() {
                if c.is_ascii_digit() {
                    j += 1;
                    continue;
                } else {
                    break;
                }
            }
            j += 1;
        }

        // segment = [start, j)
        let segment: String = chars[start..j].iter().collect();
        let digits: String = segment.chars().filter(|c| c.is_ascii_digit()).collect();

        if digits.len() != 4 {
            i += 1;
            continue;
        }

        let year: i32 = match digits.parse() {
            Ok(y) => y,
            Err(_) => {
                i += 1;
                continue;
            }
        };

        if !(2018..=2050).contains(&year) {
            i += 1;
            continue;
        }

        let last_digit_pos = find_last_digit_pos(&chars, start, j).unwrap_or(j.saturating_sub(1));
        if !has_r_within_3(&chars, last_digit_pos) {
            i += 1;
            continue;
        }

        // Chcemy podmienić możliwie cały "blob" roku + ewentualne " r." zaraz po nim,
        // ale NIE wyjść poza komórkę.
        let mut replace_end = j;
        replace_end = consume_r_suffix(&chars, replace_end, 3);

        let target_len = replace_end.saturating_sub(start);
        if target_len == 0 {
            i += 1;
            continue;
        }

        // Preferowana forma
        let candidates = [
            format!("{} r.", year),
            format!("{} r", year),
            format!("{}r", year),
        ];

        // wybierz najdłuższą, która się zmieści; potem dopaduj spacjami do dokładnego target_len
        let mut chosen: Option<String> = None;
        for c in candidates.iter() {
            if c.chars().count() <= target_len {
                chosen = Some(c.clone());
                break; // candidates są od najdłuższego do najkrótszego
            }
        }

        let Some(mut rep) = chosen else {
            // nie da się zmieścić — nie dotykamy
            i += 1;
            continue;
        };

        // dopaduj spacjami do target_len
        let rep_len = rep.chars().count();
        if rep_len < target_len {
            rep.push_str(&" ".repeat(target_len - rep_len));
        } else if rep_len > target_len {
            // nie powinno się zdarzyć, bo sprawdziliśmy, ale zostawmy bezpiecznik
            rep = rep.chars().take(target_len).collect();
        }

        // Nadpisz zakres [start, replace_end) w out
        let rep_chars: Vec<char> = rep.chars().collect();
        for k in 0..target_len {
            out[start + k] = rep_chars[k];
        }

        // Przeskocz za zastąpionym zakresem
        i = replace_end;
    }

    out.into_iter().collect()
}

// ------------------------------------------------------------
// Helpers
// ------------------------------------------------------------

fn find_last_digit_pos(chars: &[char], start: usize, end: usize) -> Option<usize> {
    for idx in (start..end).rev() {
        if chars[idx].is_ascii_digit() {
            return Some(idx);
        }
    }
    None
}

fn has_r_within_3(chars: &[char], last_digit_pos: usize) -> bool {
    let from = last_digit_pos + 1;
    let to = usize::min(chars.len(), last_digit_pos + 4);
    for k in from..to {
        let c = chars[k];
        if c == 'r' || c == 'R' {
            return true;
        }
    }
    false
}

/// Konsumuje do `max_chars` znaków po `idx` jeśli wyglądają na sufiks " r." / "r." / "r"
/// (spacje, 'r'/'R', kropki). Zwraca nowe idx.
fn consume_r_suffix(chars: &[char], mut idx: usize, max_chars: usize) -> usize {
    let mut consumed = 0;
    while idx < chars.len() && consumed < max_chars {
        let c = chars[idx];
        if c.is_whitespace() || c == '.' || c == 'r' || c == 'R' {
            idx += 1;
            consumed += 1;
            continue;
        }
        break;
    }
    idx
}
