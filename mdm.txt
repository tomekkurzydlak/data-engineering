// src/internals/md_postprocess.rs

pub fn postprocess_markdownify(md: &str) -> String {
    let md = normalize_years(md);
    let md = normalize_currencies(&md);
    mark_headings(&md)
}

pub fn mark_headings(md: &str) -> String {
    let lines: Vec<&str> = md.lines().collect();
    let mut out: Vec<String> = Vec::with_capacity(lines.len());

    for i in 0..lines.len() {
        let line = lines[i];
        let trimmed = line.trim();

        if trimmed.is_empty() {
            out.push(String::new());
            continue;
        }

        let prev_empty = i == 0 || lines[i - 1].trim().is_empty();
        let next_empty = i + 1 >= lines.len() || lines[i + 1].trim().is_empty();

        if is_candidate_heading(trimmed) && prev_empty && next_empty {
            let level = if trimmed.len() <= 30 { "#" } else { "##" };
            out.push(format!("{} {}", level, normalize_heading(trimmed)));
        } else {
            out.push(line.to_string());
        }
    }

    out.join("\n")
}

fn is_candidate_heading(line: &str) -> bool {
    if line.len() > 50 {
        return false;
    }
    if !line.chars().any(|c| c.is_alphabetic()) {
        return false;
    }
    if line.ends_with('.') {
        return false;
    }

    let letters: Vec<char> = line.chars().filter(|c| c.is_alphabetic()).collect();
    letters.iter().all(|c| c.is_uppercase())
}

fn normalize_heading(line: &str) -> String {
    line.split_whitespace()
        .map(|w| {
            let mut chars = w.chars();
            match chars.next() {
                Some(first) => first.to_uppercase().collect::<String>() + &chars.as_str().to_lowercase(),
                None => String::new(),
            }
        })
        .collect::<Vec<_>>()
        .join(" ")
}

pub fn normalize_years(md: &str) -> String {
    let mut out = String::with_capacity(md.len());
    for line in md.split_inclusive('\n') {
        out.push_str(&normalize_years_in_line(line));
    }
    out
}

fn normalize_years_in_line(line: &str) -> String {
    let looks_like_table = line.contains('|') && !line.trim_start().starts_with("```");
    if !looks_like_table {
        return normalize_years_free(line);
    }

    let mut out = String::with_capacity(line.len());
    let mut cell = String::new();
    let mut in_cell = false;

    for ch in line.chars() {
        if ch == '|' {
            if in_cell {
                out.push_str(&normalize_years_cell_preserve_width(&cell));
                cell.clear();
            }
            out.push('|');
            in_cell = true;
        } else {
            if in_cell {
                cell.push(ch);
            } else {
                out.push(ch);
            }
        }
    }

    if in_cell {
        out.push_str(&normalize_years_cell_preserve_width(&cell));
    }

    out
}

fn normalize_years_free(s: &str) -> String {
    let chars: Vec<char> = s.chars().collect();
    let mut out = String::with_capacity(s.len());
    let mut i = 0;

    while i < chars.len() {
        if !chars[i].is_ascii_digit() {
            out.push(chars[i]);
            i += 1;
            continue;
        }

        let start = i;
        let mut j = i;

        while j < chars.len() {
            let c = chars[j];
            if c.is_ascii_alphanumeric() {
                if c.is_ascii_digit() {
                    j += 1;
                    continue;
                } else {
                    break;
                }
            }
            j += 1;
        }

        let segment: String = chars[start..j].iter().collect();
        let digits: String = segment.chars().filter(|c| c.is_ascii_digit()).collect();

        if digits.len() != 4 {
            out.push(chars[i]);
            i += 1;
            continue;
        }

        let year: i32 = match digits.parse() {
            Ok(y) => y,
            Err(_) => {
                out.push(chars[i]);
                i += 1;
                continue;
            }
        };

        if !(2018..=2050).contains(&year) {
            out.push(chars[i]);
            i += 1;
            continue;
        }

        let last_digit_pos = find_last_digit_pos(&chars, start, j).unwrap_or(j.saturating_sub(1));
        if !has_r_within_3(&chars, last_digit_pos) {
            out.push(chars[i]);
            i += 1;
            continue;
        }

        out.push_str(&format!("{} r", year));
        i = j;
        i = consume_r_suffix(&chars, i, 3);
    }

    out
}

fn normalize_years_cell_preserve_width(cell: &str) -> String {
    let chars: Vec<char> = cell.chars().collect();
    let mut out: Vec<char> = chars.clone();
    let mut i = 0;

    while i < chars.len() {
        if !chars[i].is_ascii_digit() {
            i += 1;
            continue;
        }

        let start = i;
        let mut j = i;

        while j < chars.len() {
            let c = chars[j];
            if c.is_ascii_alphanumeric() {
                if c.is_ascii_digit() {
                    j += 1;
                    continue;
                } else {
                    break;
                }
            }
            j += 1;
        }

        let segment: String = chars[start..j].iter().collect();
        let digits: String = segment.chars().filter(|c| c.is_ascii_digit()).collect();

        if digits.len() != 4 {
            i += 1;
            continue;
        }

        let year: i32 = match digits.parse() {
            Ok(y) => y,
            Err(_) => {
                i += 1;
                continue;
            }
        };

        if !(2018..=2050).contains(&year) {
            i += 1;
            continue;
        }

        let last_digit_pos = find_last_digit_pos(&chars, start, j).unwrap_or(j.saturating_sub(1));
        if !has_r_within_3(&chars, last_digit_pos) {
            i += 1;
            continue;
        }

        let mut replace_end = j;
        replace_end = consume_r_suffix(&chars, replace_end, 3);

        let target_len = replace_end.saturating_sub(start);
        if target_len == 0 {
            i += 1;
            continue;
        }

        let candidates = [
            format!("{} r.", year),
            format!("{} r", year),
            format!("{}r", year),
        ];

        let mut chosen: Option<String> = None;
        for c in candidates.iter() {
            if c.chars().count() <= target_len {
                chosen = Some(c.clone());
                break;
            }
        }

        let Some(mut rep) = chosen else {
            i += 1;
            continue;
        };

        let rep_len = rep.chars().count();
        if rep_len < target_len {
            rep.push_str(&" ".repeat(target_len - rep_len));
        } else if rep_len > target_len {
            rep = rep.chars().take(target_len).collect();
        }

        let rep_chars: Vec<char> = rep.chars().collect();
        for k in 0..target_len {
            out[start + k] = rep_chars[k];
        }

        i = replace_end;
    }

    out.into_iter().collect()
}

pub fn normalize_currencies(md: &str) -> String {
    let mut out = String::with_capacity(md.len());
    for line in md.split_inclusive('\n') {
        out.push_str(&normalize_currencies_in_line(line));
    }
    out
}

fn normalize_currencies_in_line(line: &str) -> String {
    let looks_like_table = line.contains('|') && !line.trim_start().starts_with("```");
    if !looks_like_table {
        return normalize_currencies_free(line);
    }

    let mut out = String::with_capacity(line.len());
    let mut cell = String::new();
    let mut in_cell = false;

    for ch in line.chars() {
        if ch == '|' {
            if in_cell {
                out.push_str(&normalize_currencies_cell_preserve_width(&cell));
                cell.clear();
            }
            out.push('|');
            in_cell = true;
        } else {
            if in_cell {
                cell.push(ch);
            } else {
                out.push(ch);
            }
        }
    }

    if in_cell {
        out.push_str(&normalize_currencies_cell_preserve_width(&cell));
    }

    out
}

fn normalize_currencies_free(s: &str) -> String {
    let chars: Vec<char> = s.chars().collect();
    let mut out = String::with_capacity(s.len());
    let mut i = 0;

    while i < chars.len() {
        if !chars[i].is_alphabetic() && chars[i] != 'ł' && chars[i] != 'Ł' {
            out.push(chars[i]);
            i += 1;
            continue;
        }

        let start = i;
        let mut j = i;

        while j < chars.len() {
            let c = chars[j];
            if c.is_ascii_digit() {
                break;
            }
            if c.is_alphabetic() || c == 'ł' || c == 'Ł' || is_currency_sep(c) {
                j += 1;
                continue;
            }
            break;
        }

        let segment: String = chars[start..j].iter().collect();
        if let Some(norm) = currency_norm_from_segment(&segment) {
            out.push_str(&norm);
            i = j;
            continue;
        }

        out.push(chars[i]);
        i += 1;
    }

    out
}

fn normalize_currencies_cell_preserve_width(cell: &str) -> String {
    let chars: Vec<char> = cell.chars().collect();
    let mut out: Vec<char> = chars.clone();
    let mut i = 0;

    while i < chars.len() {
        let c0 = chars[i];
        if !c0.is_alphabetic() && c0 != 'ł' && c0 != 'Ł' {
            i += 1;
            continue;
        }

        let start = i;
        let mut j = i;

        while j < chars.len() {
            let c = chars[j];
            if c.is_ascii_digit() {
                break;
            }
            if c.is_alphabetic() || c == 'ł' || c == 'Ł' || is_currency_sep(c) {
                j += 1;
                continue;
            }
            break;
        }

        let segment: String = chars[start..j].iter().collect();
        let Some(norm) = currency_norm_from_segment(&segment) else {
            i += 1;
            continue;
        };

        let target_len = j.saturating_sub(start);
        if target_len == 0 {
            i += 1;
            continue;
        }

        let candidates = currency_candidates(&norm);
        let mut chosen: Option<String> = None;
        for cand in candidates {
            if cand.chars().count() <= target_len {
                chosen = Some(cand);
                break;
            }
        }

        let Some(mut rep) = chosen else {
            i += 1;
            continue;
        };

        let rep_len = rep.chars().count();
        if rep_len < target_len {
            rep.push_str(&" ".repeat(target_len - rep_len));
        } else if rep_len > target_len {
            rep = rep.chars().take(target_len).collect();
        }

        let rep_chars: Vec<char> = rep.chars().collect();
        for k in 0..target_len {
            out[start + k] = rep_chars[k];
        }

        i = j;
    }

    out.into_iter().collect()
}

fn currency_candidates(norm: &str) -> Vec<String> {
    if norm == "zł" {
        vec!["zł".to_string(), "zl".to_string(), "PLN".to_string()]
    } else {
        vec![norm.to_string(), norm.to_lowercase()]
    }
}

fn currency_norm_from_segment(segment: &str) -> Option<String> {
    let letters: String = segment
        .chars()
        .filter(|c| c.is_alphabetic() || *c == 'ł' || *c == 'Ł')
        .collect();

    if letters.is_empty() {
        return None;
    }

    let folded = letters.to_lowercase();

    if folded == "zł" || folded == "zl" || folded == "pln" {
        return Some("zł".to_string());
    }

    match folded.as_str() {
        "eur" => Some("EUR".to_string()),
        "usd" => Some("USD".to_string()),
        "gbp" => Some("GBP".to_string()),
        "chf" => Some("CHF".to_string()),
        "czk" => Some("CZK".to_string()),
        "nok" => Some("NOK".to_string()),
        "sek" => Some("SEK".to_string()),
        "dkk" => Some("DKK".to_string()),
        "huf" => Some("HUF".to_string()),
        "jpy" => Some("JPY".to_string()),
        "cad" => Some("CAD".to_string()),
        "aud" => Some("AUD".to_string()),
        _ => None,
    }
}

fn is_currency_sep(c: char) -> bool {
    c.is_whitespace() || c == '-' || c == '_' || c == '.' || c == '/' || c == '—' || c == '–'
}

fn find_last_digit_pos(chars: &[char], start: usize, end: usize) -> Option<usize> {
    for idx in (start..end).rev() {
        if chars[idx].is_ascii_digit() {
            return Some(idx);
        }
    }
    None
}

fn has_r_within_3(chars: &[char], last_digit_pos: usize) -> bool {
    let from = last_digit_pos + 1;
    let to = usize::min(chars.len(), last_digit_pos + 4);
    for k in from..to {
        let c = chars[k];
        if c == 'r' || c == 'R' {
            return true;
        }
    }
    false
}

fn consume_r_suffix(chars: &[char], mut idx: usize, max_chars: usize) -> usize {
    let mut consumed = 0;
    while idx < chars.len() && consumed < max_chars {
        let c = chars[idx];
        if c.is_whitespace() || c == '.' || c == 'r' || c == 'R' {
            idx += 1;
            consumed += 1;
            continue;
        }
        break;
    }
    idx
}
