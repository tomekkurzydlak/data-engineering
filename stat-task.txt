async fn process_static_task(
    &self,
    task: FileTask,
    tx: &Sender<FileTask>,
    remaining_files: &Arc<AtomicUsize>,
    steps_cache: &Arc<DashMap<String, VecDeque<ProcessStep>>>,
) -> Result<()> {
    let file_id = &task.file_id;
    let gcs_file_uri = &task.gcs_file_uri;
    let step = &task.step;

    // ---------------------------------------------------------
    // 1. Przygotowanie env-vars z TGT_PATH
    // ---------------------------------------------------------
    let trg = step
        .params
        .as_ref()
        .and_then(|m| m.get("trg_path"))
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let mut envs = self.cfg.env_vars.clone();
    envs.insert("TGT_PATH".into(), trg.to_string());

    // ---------------------------------------------------------
    // 2. Start joba w Cloud Run
    // ---------------------------------------------------------
    let payload = serde_json::json!({
        "process_id": self.cfg.process_id,
        "dispatcher_run_id": self.dispatcher_run_id.to_string(),
        "file_id": file_id,
        "gcs_file_uri": gcs_file_uri,
        "process_cd": step.process_cd,
        "seq": step.exec_process_seq,
    });

    let job_name = &step.exec_object_nm;

    let exec_id = if let Some(cr) = self.backend.as_any().downcast_ref::<CloudRunBackend>() {
        cr.start_job(job_name, &payload, &envs).await?
    } else {
        self.backend.dispatch_job(job_name, &payload).await?
    };

    if let Some(cr) = self.backend.as_any().downcast_ref::<CloudRunBackend>() {
        cr.poll_until_done(&exec_id, Duration::from_secs(60*30), Duration::from_secs(10)).await?;
    }

    // ---------------------------------------------------------
    // 3. Pobieranie kolejnego kroku z cache
    // ---------------------------------------------------------
    if let Some(mut entry) = steps_cache.get_mut(file_id) {
        if let Some(next_step) = entry.pop_front() {
            let queue_empty = entry.is_empty();
            drop(entry);
            if queue_empty {
                steps_cache.remove(file_id);
            }

            let new_task = FileTask {
                file_id: file_id.clone(),
                gcs_file_uri: gcs_file_uri.clone(),
                step: next_step,
            };
            tx.send(new_task)?;
            return Ok(());
        } else {
            drop(entry);
            steps_cache.remove(file_id);
        }
    }

    // ---------------------------------------------------------
    // 4. Brak kroków → koniec pipeline dla pliku
    // ---------------------------------------------------------
    remaining_files.fetch_sub(1, Ordering::AcqRel);
    Ok(())
}

=====


async fn run_static_wfl_async_jobs(&self, files: Vec<FileProcess>) -> Result<()> {
    let (tx, rx): (Sender<FileTask>, Receiver<FileTask>) = unbounded();

    let remaining_files = Arc::new(AtomicUsize::new(files.len()));
    let steps_cache: Arc<DashMap<String, VecDeque<ProcessStep>>> = Arc::new(DashMap::new());

    // 1. Zbuduj steps_cache i wrzuć pierwszy krok dla każdego pliku
    for f in &files {
        if f.processes.is_empty() {
            remaining_files.fetch_sub(1, Ordering::AcqRel);
            continue;
        }

        // sort
        let mut steps = f.processes.clone();
        steps.sort_by_key(|s| s.exec_process_seq);

        // pierwszy krok → osobno
        let first_step = steps.remove(0);

        // reszta kroków → do cache
        steps_cache.insert(f.file_id.clone(), steps.into());

        // wrzucamy pierwszy task
        tx.send(FileTask {
            file_id: f.file_id.clone(),
            gcs_file_uri: f.gcs_file_uri.clone(),
            step: first_step,
        })?;
    }

    drop(files);

    // 2. Spawn workerów
    let workers = self.cfg.max_workers;
    let mut handles = Vec::new();
    let rt = tokio::runtime::Handle::current();

    for _ in 0..workers {
        let rx_c = rx.clone();
        let tx_c = tx.clone();
        let dispatcher = self.clone_light();
        let remaining_c = Arc::clone(&remaining_files);
        let cache_c = Arc::clone(&steps_cache);

        handles.push(std::thread::spawn(move || {
            while let Ok(task) = rx_c.recv() {
                let _ = rt.block_on(async {
                    dispatcher
                        .process_static_task(task, &tx_c, &remaining_c, &cache_c)
                        .await
                });
            }
        }));
    }

    drop(tx);

    for h in handles {
        let _ = h.join();
    }

    Ok(())
}
