use pdfium_render::prelude::*;
use std::collections::BTreeMap;
use std::fs::File;
use std::io::{BufWriter, Write};

#[derive(Debug, Clone)]
struct TextItem {
    text: String,
    x0: f32,
    y0: f32,
    x1: f32,
    y1: f32,
    font_size: f32,
}


fn is_footer_line(s: &str) -> bool {
    let t = s.trim();
    if t.is_empty() { return false; }
    let lower = t.to_lowercase();

    // typowe wzorce w stopkach PLAY / dokumentów prawnych
    lower.contains("p4 sp. z o.o")
        || lower.contains("krs")
        || lower.contains("regon")
        || lower.contains("nip")
        || lower.contains("kapitał zakładowy")
        || lower.contains("sąd rejonowy")
        || lower.contains("strona")
        || lower.contains("wynalazek 1")
}


fn is_noise_cell(s: &str) -> bool {
    let t = s.trim();
    if t.is_empty() { return true; }
    // pojedyncze znaki które często są artefaktami
    if t.len() == 1 {
        let c = t.chars().next().unwrap();
        return c == '.' || c == '-' || c == '|' || c == ',' || c == '•';
    }
    false
}

fn is_noise_row(cols: &[String]) -> bool {
    // policz niepuste
    let non_empty: Vec<&str> = cols.iter()
        .map(|c| c.trim())
        .filter(|t| !t.is_empty())
        .collect();

    // 0 komórek -> szum
    if non_empty.is_empty() {
        return true;
    }

    // 1 komórka -> prawie zawsze to NIE jest tabela (to są właśnie Twoje "mini tabelki")
    // wyjątek: można by dopuścić np. wiersze stricte-numeryczne, ale w tych PDF-ach to bardziej szkodzi niż pomaga
    if non_empty.len() == 1 {
        return true;
    }

    // odfiltruj "artefakty"
    let noisy = cols.iter().filter(|c| is_noise_cell(c)).count();

    // jeśli większość komórek to szum/pusto -> wywal
    noisy * 2 >= cols.len().max(1)
}


impl TextItem {
    fn cx(&self) -> f32 {
        (self.x0 + self.x1) * 0.5
    }
    fn cy(&self) -> f32 {
        (self.y0 + self.y1) * 0.5
    }
}

#[derive(Debug, Clone)]
struct LineSeg {
    x0: f32,
    y0: f32,
    x1: f32,
    y1: f32,
}

impl LineSeg {
    fn is_horizontal(&self, tol: f32) -> bool {
        (self.y0 - self.y1).abs() <= tol && (self.x1 - self.x0).abs() > 15.0
    }
    fn is_vertical(&self, tol: f32) -> bool {
        (self.x0 - self.x1).abs() <= tol && (self.y1 - self.y0).abs() > 15.0
    }
}

#[derive(Debug, Clone)]
struct TableGrid {
    x_lines: Vec<f32>,
    y_lines: Vec<f32>,
    min_x: f32,
    max_x: f32,
    min_y: f32,
    max_y: f32,
}

fn approx_dedup_sorted(mut v: Vec<f32>, eps: f32) -> Vec<f32> {
    v.sort_by(|a, b| a.partial_cmp(b).unwrap());
    let mut out: Vec<f32> = Vec::new();
    for x in v {
        if out.last().map(|last| (x - *last).abs() > eps).unwrap_or(true) {
            out.push(x);
        }
    }
    out
}

fn collect_text_items(page: &PdfPage) -> Vec<TextItem> {
    let mut out = Vec::new();

    for obj in page.objects().iter() {
        if let Some(t) = obj.as_text_object() {
            let s = t.text();
            let s = s.trim().to_string();
            if s.is_empty() {
                continue;
            }

            if let Ok(b) = t.bounds() {
                let x0 = b.left().value;
                let x1 = b.right().value;
                let y0 = b.bottom().value;
                let y1 = b.top().value;
                let font_size = t.scaled_font_size().value;

                out.push(TextItem {
                    text: s,
                    x0,
                    y0,
                    x1,
                    y1,
                    font_size,
                });
            }
        }
    }

    out
}

fn collect_line_segs(page: &PdfPage) -> Vec<LineSeg> {
    let mut out = Vec::new();

    for obj in page.objects().iter() {
        if let Some(p) = obj.as_path_object() {
            if let Ok(b) = p.bounds() {
                let x0 = b.left().value;
                let x1 = b.right().value;
                let y0 = b.bottom().value;
                let y1 = b.top().value;

                let w = (x1 - x0).abs();
                let h = (y1 - y0).abs();

                if w > 30.0 && h < 3.0 {
                    out.push(LineSeg { x0, y0: (y0 + y1) * 0.5, x1, y1: (y0 + y1) * 0.5 });
                } else if h > 20.0 && w < 3.0 {
                    out.push(LineSeg { x0: (x0 + x1) * 0.5, y0, x1: (x0 + x1) * 0.5, y1 });
                }
            }
        }
    }

    out
}

fn detect_table_grid(line_segs: &[LineSeg]) -> Option<TableGrid> {
    if line_segs.len() < 4 {
        return None;
    }

    let hor_tol = 3.0;
    let ver_tol = 3.0;

    let horizontals: Vec<&LineSeg> = line_segs.iter().filter(|s| s.is_horizontal(hor_tol)).collect();
    let verticals: Vec<&LineSeg> = line_segs.iter().filter(|s| s.is_vertical(ver_tol)).collect();

    // Potrzebujemy przynajmniej 3 poziomych (góra, dół + 1 separator) i 1 pionowej
    if horizontals.len() < 3 || verticals.len() < 1 {
        return None;
    }

    // Znajdź główną tabelę - linie o podobnej długości
    let h_lengths: Vec<f32> = horizontals.iter().map(|s| (s.x1 - s.x0).abs()).collect();
    let avg_h_len = h_lengths.iter().sum::<f32>() / h_lengths.len() as f32;

    // Filtruj linie poziome - tylko te które są co najmniej 70% średniej długości
    let h_main: Vec<&LineSeg> = horizontals
        .iter()
        .filter(|s| {
            let len = (s.x1 - s.x0).abs();
            len >= avg_h_len * 0.7
        })
        .copied()
        .collect();

    if h_main.len() < 3 {
        return None;
    }

    // Zbierz pozycje X i Y
    let mut xs: Vec<f32> = Vec::new();
    let mut ys: Vec<f32> = Vec::new();

    // Dodaj pionowe linie
    for v in &verticals {
        xs.push(v.x0);
    }

    // Dodaj granice i pozycje z poziomych
    for h in &h_main {
        xs.push(h.x0);
        xs.push(h.x1);
        ys.push(h.y0);
    }

    xs = approx_dedup_sorted(xs, 10.0);
    ys = approx_dedup_sorted(ys, 5.0);

    if xs.len() < 2 || ys.len() < 3 {
        return None;
    }

    // Ograniczenie kolumn - max 6 dla typowych tabel
    if xs.len() > 7 {
        return None;
    }

    let min_x = *xs.first().unwrap();
    let max_x = *xs.last().unwrap();
    let min_y = *ys.first().unwrap();
    let max_y = *ys.last().unwrap();

    let width = max_x - min_x;
    let height = max_y - min_y;

    // Tabela musi mieć sensowny rozmiar
    if width < 150.0 || height < 60.0 {
        return None;
    }

    // Wysokość nie powinna być zbyt duża dla pojedynczej tabeli
    if height > 500.0 {
        return None;
    }

    Some(TableGrid { x_lines: xs, y_lines: ys, min_x, max_x, min_y, max_y })
}

fn group_text_into_lines(items: &[TextItem], y_band: f32) -> Vec<Vec<TextItem>> {
    let mut map: BTreeMap<i32, Vec<TextItem>> = BTreeMap::new();

    for it in items {
        let key = (it.cy() / y_band).round() as i32;
        map.entry(key).or_default().push(it.clone());
    }

    let mut lines: Vec<(i32, Vec<TextItem>)> = map.into_iter().collect();
    lines.sort_by(|a, b| b.0.cmp(&a.0));

    for (_, line) in &mut lines {
        line.sort_by(|a, b| a.x0.partial_cmp(&b.x0).unwrap());
    }

    lines.into_iter().map(|(_, v)| v).collect()
}

fn is_inside_table(line: &[TextItem], grid: &TableGrid) -> bool {
    if line.is_empty() {
        return false;
    }

    // Sprawdź czy większość tekstu jest w granicach X tabeli
    let mut inside_x = 0usize;
    let mut inside_full = 0usize;

    for it in line {
        let cx = it.cx();
        let cy = it.cy();

        // Czy w zakresie X?
        if cx >= grid.min_x - 5.0 && cx <= grid.max_x + 5.0 {
            inside_x += 1;

            // Czy też w zakresie Y?
            if cy >= grid.min_y - 15.0 && cy <= grid.max_y + 15.0 {
                inside_full += 1;
            }
        }
    }

    // Musi być w X i przynajmniej częściowo w Y
    inside_x >= ((line.len() as f32) * 0.7) as usize &&
        inside_full >= ((line.len() as f32) * 0.5) as usize
}

fn assign_to_columns(line: &[TextItem], grid: &TableGrid) -> Vec<String> {
    let col_count = grid.x_lines.len().saturating_sub(1);
    if col_count == 0 {
        return vec![line.iter().map(|t| t.text.as_str()).collect::<Vec<_>>().join(" ")];
    }

    let mut cols: Vec<Vec<&TextItem>> = vec![Vec::new(); col_count];

    for it in line {
        let cx = it.cx();

        // Przypisz do kolumny zawierającej punkt
        let mut assigned = false;
        for i in 0..col_count {
            let left = grid.x_lines[i];
            let right = grid.x_lines[i + 1];

            if cx >= left - 3.0 && cx < right + 3.0 {
                cols[i].push(it);
                assigned = true;
                break;
            }
        }

        // Jeśli nie pasuje, znajdź najbliższą kolumnę
        if !assigned {
            let mut best_idx = 0;
            let mut best_dist = f32::INFINITY;

            for i in 0..col_count {
                let left = grid.x_lines[i];
                let right = grid.x_lines[i + 1];
                let center = (left + right) * 0.5;
                let dist = (cx - center).abs();

                if dist < best_dist {
                    best_dist = dist;
                    best_idx = i;
                }
            }

            cols[best_idx].push(it);
        }
    }

    cols.into_iter()
        .map(|mut cell| {
            cell.sort_by(|a, b| a.x0.partial_cmp(&b.x0).unwrap());
            let s = cell
                .into_iter()
                .map(|t| t.text.as_str())
                .collect::<Vec<_>>()
                .join(" ");
            s.trim().to_string()
        })
        .collect()
}

fn render_table_row_md(cols: &[String]) -> String {
    let esc = |s: &str| s.replace('|', "\\|").replace('\n', " ");
    let cells = cols.iter().map(|c| esc(c)).collect::<Vec<_>>();
    format!("| {} |", cells.join(" | "))
}

fn is_heading_line(line: &[TextItem], body_font_guess: f32) -> Option<usize> {
    if line.is_empty() {
        return None;
    }

    let avg = line.iter().map(|t| t.font_size).sum::<f32>() / line.len() as f32;

    if avg >= body_font_guess * 1.5 {
        Some(1)
    } else if avg >= body_font_guess * 1.3 {
        Some(2)
    } else if avg >= body_font_guess * 1.15 {
        Some(3)
    } else {
        None
    }
}

fn guess_body_font(items: &[TextItem]) -> f32 {
    let mut v: Vec<f32> = items.iter().map(|t| t.font_size).collect();
    if v.is_empty() {
        return 12.0;
    }
    v.sort_by(|a, b| a.partial_cmp(b).unwrap());
    v[v.len() / 2].max(9.0)
}
fn is_table_marker_line(s: &str) -> bool {
    let t = s.trim();
    t.starts_with("Tabela 1") || t.starts_with("Tabela 2") || t.starts_with("Tabela 3")
}

fn looks_like_group_header(s: &str) -> bool {
    // "GRUPA L 5G / PLAY L 5G"
    let l = s.to_lowercase();
    l.contains("grupa") && l.contains("play")
}
fn looks_like_lp_header(s: &str) -> bool {
    // "LP." i "Taryfa / oferta" bywają rozrzucone na 1–2 linie
    let l = s.to_lowercase();
    (l.contains("lp") || l.contains("lp.")) && (l.contains("taryfa") || l.contains("oferta"))
}

fn starts_with_lp_number(s: &str) -> Option<String> {
    // "2." "3." "5." -> "2" "3" "5"
    let first = s.split_whitespace().next()?;
    if first.ends_with('.') {
        let n = first.trim_end_matches('.');
        if !n.is_empty() && n.chars().all(|c| c.is_ascii_digit()) {
            return Some(n.to_string());
        }
    }
    None
}

fn try_render_price_table_block(
    out: &mut BufWriter<File>,
    lines: &[Vec<TextItem>],
    start_idx: usize,
) -> Option<usize> {
    let mut i = start_idx;

    // 0) tytuł tabeli jako heading
    let title = lines[i]
        .iter()
        .map(|t| t.text.as_str())
        .collect::<Vec<_>>()
        .join(" ");
    writeln!(out, "\n### {}\n", title.trim()).ok()?;
    i += 1;

    // 1) PREAMBLE: zbieramy:
    // - group header: "GRUPA ... PLAY ..."
    // - ewentualne linie typu "LP. Taryfa/oferta" jako preface (nie do tabeli)
    // - plus headers: "(+10) ... (+250)" -> header kolumn
    let mut group_header_acc = String::new();
    let mut preface_acc: Vec<String> = Vec::new();
    let mut plus_headers: Vec<String> = Vec::new();

    while i < lines.len() {
        let plain = lines[i]
            .iter()
            .map(|t| t.text.as_str())
            .collect::<Vec<_>>()
            .join(" ");
        let plain = plain.trim().to_string();

        if plain.is_empty() {
            i += 1;
            continue;
        }

        // stopki / kolejna tabela
        if is_footer_line(&plain) {
            return None;
        }
        if i != start_idx && is_table_marker_line(&plain) {
            return None;
        }

        if looks_like_group_header(&plain) {
            if !group_header_acc.is_empty() {
                group_header_acc.push(' ');
            }
            group_header_acc.push_str(&plain);
            i += 1;
            continue;
        }

        // zlepiaj "LP" / "Taryfa/oferta" / "Pozycja w cenniku" w preface
        if looks_like_lp_header(&plain) || plain.to_lowercase().contains("pozycja") || plain.to_lowercase().contains("cenniku") {
            preface_acc.push(plain);
            i += 1;
            continue;
        }

        // szukamy linii z (+..)
        let toks = extract_money_like_tokens(&plain);
        let plus_cnt = toks.iter().filter(|t| t.starts_with("(+")).count();
        if plus_cnt >= 6 {
            plus_headers = toks.into_iter().filter(|t| t.starts_with("(+")).collect();
            i += 1;
            break;
        }

        // jeżeli trafiliśmy na coś innego zanim znaleźliśmy (+..),
        // to zwykle jest to fragment tytułu/wstępu – ale nie pakujmy tego w label.
        // Zapisz jako preface i idź dalej (max kilka linii).
        if preface_acc.len() < 4 {
            preface_acc.push(plain);
            i += 1;
            continue;
        }

        i += 1;
    }

    if plus_headers.is_empty() {
        return None;
    }

    // 2) Wypisz grupę i preface jako tekst NAD tabelą
    if !group_header_acc.trim().is_empty() {
        writeln!(out, "**{}**\n", group_header_acc.trim()).ok()?;
    }
    if !preface_acc.is_empty() {
        // żeby nie dublować i nie robić śmietnika – jedna linia
        let merged = preface_acc.join(" ");
        writeln!(out, "**{}**\n", merged.trim()).ok()?;
    }

    // 3) Header tabeli: LP | Opis | (+10) ... (+250)
    let mut header: Vec<String> = Vec::new();
    header.push("LP".to_string());
    header.push("Opis".to_string());
    header.extend(plus_headers.clone());

    writeln!(out, "{}", render_table_row_md(&header)).ok()?;
    writeln!(
        out,
        "|{}|",
        header.iter().map(|_| "---").collect::<Vec<_>>().join("|")
    )
        .ok()?;

    // 4) DATA: Budujemy wiersze tak:
    // - zbieramy opis (pending_desc) z linii niecenowych
    // - gdy pojawi się linia cenowa (>=6 "xx zł") => emit wiersz
    // - po min. 2 wierszach: jeśli trafi się zwykły tekst bez cen => koniec tabeli
    let target_cols = plus_headers.len();
    let mut pending_desc: Option<String> = None;
    let mut pending_lp: Option<String> = None;
    let mut rows_emitted = 0usize;

    while i < lines.len() {
        let plain = lines[i]
            .iter()
            .map(|t| t.text.as_str())
            .collect::<Vec<_>>()
            .join(" ");
        let plain = plain.trim().to_string();

        if plain.is_empty() {
            i += 1;
            continue;
        }

        // stop
        if is_footer_line(&plain) || (i != start_idx && is_table_marker_line(&plain)) {
            break;
        }

        // koniec tabeli po wejściu w "tekst ciągły" (po tym jak już coś wyrenderowaliśmy)
        if rows_emitted >= 2 && !is_price_row(&plain) {
            // jeżeli wygląda jak zwykły paragraf – wychodzimy
            let low = plain.to_lowercase();
            let looks_like_paragraph = low.contains("nielimitowane")
                || low.contains("obejmuje")
                || low.contains("internet")
                || low.contains("nie dotyczy")
                || low.contains("sms")
                || low.contains("mms");
            if looks_like_paragraph {
                break;
            }
        }

        if is_price_row(&plain) {
            // LP i reszta tekstu
            let (rest, lp_opt) = strip_leading_lp_token(&plain);
            let lp = lp_opt.or_else(|| pending_lp.take()).unwrap_or_else(|| "".to_string());

            // ceny: tylko "xx zł"
            let mut vals = extract_money_like_tokens(&plain);
            let mut zl_vals: Vec<String> = vals
                .drain(..)
                .filter(|t| t.ends_with("zł"))
                .collect();

            // Jeżeli w tej linii nie ma "zł" (bo to byłby nagłówek plusów) – pomijamy
            if zl_vals.is_empty() {
                i += 1;
                continue;
            }

            // opis: preferuj pending_desc, ale jak brak – bierz rest
            let mut desc = pending_desc.take().unwrap_or_else(|| rest.trim().to_string());
            desc = desc.replace("  ", " ").trim().to_string();

            // Heurystyka: Pdfium często robi "2." na osobnej linii, a ceny na następnej.
            // Jeśli desc jest puste albo wygląda jak urwany fragment, dołącz rest.
            if desc.is_empty() && !rest.trim().is_empty() {
                desc = rest.trim().to_string();
            }

            let mut row: Vec<String> = Vec::with_capacity(2 + target_cols);
            row.push(lp);
            row.push(desc);

            // Przypadek jednej ceny na całą tabelę (np. "4. 10 zł")
            if zl_vals.len() == 1 {
                row.push(zl_vals[0].clone());
                for _ in 1..target_cols {
                    row.push("".to_string());
                }
            } else {
                // normalny przypadek: dużo cen
                if zl_vals.len() > target_cols {
                    zl_vals.truncate(target_cols);
                }
                for v in zl_vals {
                    row.push(v);
                }
                while row.len() < 2 + target_cols {
                    row.push("".to_string());
                }
            }

            if !is_noise_row(&row) {
                writeln!(out, "{}", render_table_row_md(&row)).ok()?;
                rows_emitted += 1;
            }

            i += 1;
            continue;
        }

        // Linia niecenowa: budujemy opis
        // - jeśli zaczyna się od "2." / "3." / "5." i nie ma cen: traktuj jako start nowego opisu
        if let Some(lp) = starts_with_lp_number(&plain) {
            pending_lp = Some(lp);
            let (rest, _) = strip_leading_lp_token(&plain);
            let rest = rest.trim().to_string();
            if !rest.is_empty() {
                pending_desc = Some(rest);
            }
            i += 1;
            continue;
        }

        // kontynuacja opisu (sklej), ale tylko do sensownej długości (żeby nie wciągać pół strony)
        let max_len = 180usize;
        match pending_desc.take() {
            None => {
                pending_desc = Some(plain);
            }
            Some(prev) => {
                let merged = format!("{} {}", prev, plain).replace("  ", " ");
                pending_desc = Some(merged.chars().take(max_len).collect());
            }
        }

        i += 1;
    }

    writeln!(out).ok()?;
    Some(i)
}



fn strip_leading_lp_token(s: &str) -> (&str, Option<String>) {
    let t = s.trim_start();
    let mut it = t.split_whitespace();

    if let Some(first) = it.next() {
        if first.ends_with('.') {
            let n = first.trim_end_matches('.');
            if !n.is_empty() && n.chars().all(|c| c.is_ascii_digit()) {
                let rest = t[first.len()..].trim_start();
                return (rest, Some(n.to_string()));
            }
        }
    }
    (t, None)
}


fn main() -> Result<(), PdfiumError> {
    let pdfium = Pdfium::new(Pdfium::bind_to_library("libpdfium.dylib")?);
    let document = pdfium.load_pdf_from_file("tp4.pdf", None)?;

    let file = File::create("output2.md").expect("Błąd pliku");
    let mut out = BufWriter::new(file);

    for (page_idx, page) in document.pages().iter().enumerate() {
        writeln!(out, "\n\n---\n## Page {}\n", page_idx + 1).unwrap();

        let text_items = collect_text_items(&page);
        let body_font = guess_body_font(&text_items);

        let line_segs = collect_line_segs(&page);
        let table_grid = detect_table_grid(&line_segs);

        if let Some(g) = &table_grid {
            writeln!(
                out,
                "> Detected table grid: cols={}, rows={}, bbox=({:.1},{:.1})-({:.1},{:.1})\n",
                g.x_lines.len().saturating_sub(1),
                g.y_lines.len().saturating_sub(1),
                g.min_x, g.min_y, g.max_x, g.max_y
            )
                .unwrap();
        }

        let lines = group_text_into_lines(&text_items, 2.5);

        let mut in_grid_table = false;
        let mut grid_header_written = false;

        let mut idx = 0usize;
        while idx < lines.len() {
            let line = lines[idx].clone();
            let plain = line.iter().map(|t| t.text.as_str()).collect::<Vec<_>>().join(" ");
            let plain = plain.trim().to_string();
            if plain.is_empty() {
                idx += 1;
                continue;
            }

            // HARD BREAK stopki
            if is_footer_line(&plain) {
                if in_grid_table {
                    in_grid_table = false;
                    grid_header_written = false;
                    writeln!(out).unwrap();
                }
                writeln!(out, "{}\n", plain).unwrap();
                idx += 1;
                continue;
            }

            // SPECJALNY BLOK: Tabela 2 / Tabela 3 (Page 2)
            if plain.starts_with("Tabela 2") || plain.starts_with("Tabela 3") {
                if in_grid_table {
                    in_grid_table = false;
                    grid_header_written = false;
                    writeln!(out).unwrap();
                }

                if let Some(next_idx) = try_render_price_table_block(&mut out, &lines, idx) {
                    idx = next_idx;
                    continue;
                }
            }

            // GRID TABLE (jeśli wykryty)
            let is_grid_line = table_grid
                .as_ref()
                .map(|g| is_inside_table(&line, g))
                .unwrap_or(false);

            if is_grid_line {
                let g = table_grid.as_ref().unwrap();

                if !in_grid_table {
                    in_grid_table = true;
                    grid_header_written = false;
                    writeln!(out).unwrap();
                }

                let cols = assign_to_columns(&line, g);

                if is_noise_row(&cols) {
                    idx += 1;
                    continue;
                }

                if !grid_header_written {
                    writeln!(out, "{}", render_table_row_md(&cols)).unwrap();
                    writeln!(out, "|{}|", cols.iter().map(|_| "---").collect::<Vec<_>>().join("|")).unwrap();
                    grid_header_written = true;
                } else {
                    writeln!(out, "{}", render_table_row_md(&cols)).unwrap();
                }

                idx += 1;
                continue;
            } else if in_grid_table {
                in_grid_table = false;
                grid_header_written = false;
                writeln!(out).unwrap();
            }

            // Heading / paragraf
            if let Some(level) = is_heading_line(&line, body_font) {
                let hashes = match level {
                    1 => "#",
                    2 => "##",
                    _ => "###",
                };
                writeln!(out, "\n{} {}\n", hashes, plain).unwrap();
            } else {
                writeln!(out, "{}\n", plain).unwrap();
            }

            idx += 1;
        }

        if in_grid_table {
            writeln!(out).unwrap();
        }
    }

    out.flush().unwrap();
    println!("OK: zapisano output2.md");
    Ok(())
}

fn extract_money_like_tokens(plain: &str) -> Vec<String> {
    let toks: Vec<&str> = plain.split_whitespace().collect();
    let mut out: Vec<String> = Vec::new();

    let mut i = 0usize;
    while i < toks.len() {
        let t = toks[i].trim();

        // "(+10)" itp.
        if t.starts_with("(+") && t.ends_with(')') {
            let inner = &t[2..t.len() - 1];
            if !inner.is_empty() && inner.chars().all(|c| c.is_ascii_digit()) {
                out.push(t.to_string());
            }
            i += 1;
            continue;
        }

        // "7 5 zł" -> "75 zł"
        if t.len() == 1 && t.chars().all(|c| c.is_ascii_digit()) {
            if i + 2 < toks.len()
                && toks[i + 1].len() == 1
                && toks[i + 1].chars().all(|c| c.is_ascii_digit())
                && normalize_zl(toks[i + 2]) == Some("zł")
            {
                out.push(format!("{}{} zł", t, toks[i + 1]));
                i += 3;
                continue;
            }
        }

        // "85 zł" / "0 zł"
        if t.chars().all(|c| c.is_ascii_digit()) {
            if i + 1 < toks.len() && normalize_zl(toks[i + 1]) == Some("zł") {
                out.push(format!("{} zł", t));
                i += 2;
                continue;
            }
            // same liczby czasem są w nagłówkach – zostawiamy
            out.push(t.to_string());
            i += 1;
            continue;
        }

        i += 1;
    }

    out
}

fn normalize_zl(tok: &str) -> Option<&'static str> {
    // Pdfium czasem daje "zł" z dziwnymi znakami, ale zwykle tok zaczyna się od "z"
    let t = tok.trim().to_lowercase();
    if t == "zł" || t == "zl" {
        return Some("zł");
    }
    // awaryjnie: "zł." / "zł," / "zł*" itp.
    if t.starts_with("zł") || t.starts_with("zl") {
        return Some("zł");
    }
    None
}


fn is_price_row(plain: &str) -> bool {
    let tokens = extract_money_like_tokens(plain);
    let plus_cnt = tokens.iter().filter(|t| t.starts_with("(+")).count();
    let zl_cnt = tokens.iter().filter(|t| t.ends_with("zł")).count();

    // tabelka cenowa ma dużo (+..) albo dużo "xx zł"
    plus_cnt >= 6 || zl_cnt >= 6
}

==
v2
use pdfium_render::prelude::*;
use std::collections::BTreeMap;
use std::fs::File;
use std::io::{BufWriter, Write};

#[derive(Debug, Clone)]
struct TextItem {
    text: String,
    x0: f32,
    y0: f32,
    x1: f32,
    y1: f32,
    font_size: f32,
}


fn is_footer_line(s: &str) -> bool {
    let t = s.trim();
    if t.is_empty() { return false; }
    let lower = t.to_lowercase();

    // typowe wzorce w stopkach PLAY / dokumentów prawnych
    lower.contains("p4 sp. z o.o")
        || lower.contains("krs")
        || lower.contains("regon")
        || lower.contains("nip")
        || lower.contains("kapitał zakładowy")
        || lower.contains("sąd rejonowy")
        || lower.contains("strona")
        || lower.contains("wynalazek 1")
}


fn is_noise_cell(s: &str) -> bool {
    let t = s.trim();
    if t.is_empty() { return true; }
    // pojedyncze znaki które często są artefaktami
    if t.len() == 1 {
        let c = t.chars().next().unwrap();
        return c == '.' || c == '-' || c == '|' || c == ',' || c == '•';
    }
    false
}

fn is_noise_row(cols: &[String]) -> bool {
    // policz niepuste
    let non_empty: Vec<&str> = cols.iter()
        .map(|c| c.trim())
        .filter(|t| !t.is_empty())
        .collect();

    // 0 komórek -> szum
    if non_empty.is_empty() {
        return true;
    }

    // 1 komórka -> prawie zawsze to NIE jest tabela (to są właśnie Twoje "mini tabelki")
    // wyjątek: można by dopuścić np. wiersze stricte-numeryczne, ale w tych PDF-ach to bardziej szkodzi niż pomaga
    if non_empty.len() == 1 {
        return true;
    }

    // odfiltruj "artefakty"
    let noisy = cols.iter().filter(|c| is_noise_cell(c)).count();

    // jeśli większość komórek to szum/pusto -> wywal
    noisy * 2 >= cols.len().max(1)
}


impl TextItem {
    fn cx(&self) -> f32 {
        (self.x0 + self.x1) * 0.5
    }
    fn cy(&self) -> f32 {
        (self.y0 + self.y1) * 0.5
    }
}

#[derive(Debug, Clone)]
struct LineSeg {
    x0: f32,
    y0: f32,
    x1: f32,
    y1: f32,
}

impl LineSeg {
    fn is_horizontal(&self, tol: f32) -> bool {
        (self.y0 - self.y1).abs() <= tol && (self.x1 - self.x0).abs() > 15.0
    }
    fn is_vertical(&self, tol: f32) -> bool {
        (self.x0 - self.x1).abs() <= tol && (self.y1 - self.y0).abs() > 15.0
    }
}

#[derive(Debug, Clone)]
struct TableGrid {
    x_lines: Vec<f32>,
    y_lines: Vec<f32>,
    min_x: f32,
    max_x: f32,
    min_y: f32,
    max_y: f32,
}

fn approx_dedup_sorted(mut v: Vec<f32>, eps: f32) -> Vec<f32> {
    v.sort_by(|a, b| a.partial_cmp(b).unwrap());
    let mut out: Vec<f32> = Vec::new();
    for x in v {
        if out.last().map(|last| (x - *last).abs() > eps).unwrap_or(true) {
            out.push(x);
        }
    }
    out
}
fn sanitize_text(s: &str) -> String {
    fn allowed_punct(c: char) -> bool {
        matches!(
            c,
            '.' | ',' | ':' | ';' | '!' | '?' |
            '(' | ')' | '[' | ']' | '{' | '}' |
            '"' | '\'' |
            '-' | '–' | '—' |
            '/' | '\\' |
            '|' |
            '+' | '=' |
            '*' | '%' |
            '_' |
            '@' |
            '#'
        )
    }

    fn is_latin_letter(c: char) -> bool {
        let u = c as u32;

        // ASCII letters
        if (0x0041..=0x005A).contains(&u) || (0x0061..=0x007A).contains(&u) {
            return true;
        }

        // Latin-1 Supplement + Latin Extended-A/B + Latin Extended Additional
        // (pokrywa m.in. ąęłńóśźż oraz praktycznie cały "normalny" łaciński alfabet z diakrytykami)
        (0x00C0..=0x024F).contains(&u) || (0x1E00..=0x1EFF).contains(&u)
    }

    let mut out = String::with_capacity(s.len());
    let mut prev_space = false;

    for ch in s.chars() {
        // whitespace -> pojedyncza spacja
        if ch.is_whitespace() {
            if !prev_space {
                out.push(' ');
                prev_space = true;
            }
            continue;
        }

        // kontrolne / replacement / soft hyphen
        if ch.is_control() || ch == '\u{FFFD}' || ch == '\u{00AD}' {
            continue;
        }

        // Private Use Area
        let code = ch as u32;
        if (0xE000..=0xF8FF).contains(&code) {
            continue;
        }

        // Cyfry zawsze OK
        if ch.is_ascii_digit() {
            out.push(ch);
            prev_space = false;
            continue;
        }

        // Litery tylko łacińskie (czyli np. PL znaki tak, ale ҊҎҏҐ nie)
        if is_latin_letter(ch) {
            out.push(ch);
            prev_space = false;
            continue;
        }

        // Wybrana interpunkcja
        if allowed_punct(ch) {
            out.push(ch);
            prev_space = false;
            continue;
        }

        // Reszta wylatuje
    }

    let mut out = out.trim().to_string();

    // Sklej dzielenia wyrazów: "abona- mentu" -> "abona-mentu"
    // (tylko usuwa spację po myślniku, jeżeli dalej jest litera/cyfra)
    let chars: Vec<char> = out.chars().collect();
    let mut fixed = String::with_capacity(out.len());
    let mut i = 0usize;
    while i < chars.len() {
        if chars[i] == '-' && i + 2 < chars.len() && chars[i + 1] == ' ' {
            let next = chars[i + 2];
            if next.is_ascii_digit() || is_latin_letter(next) {
                fixed.push('-');
                i += 2; // pomiń spację
                continue;
            }
        }
        fixed.push(chars[i]);
        i += 1;
    }

    // redukcja wielokrotnych spacji
    fixed.split_whitespace().collect::<Vec<_>>().join(" ")
}



fn collect_text_items(page: &PdfPage) -> Vec<TextItem> {
    let mut out = Vec::new();

    for obj in page.objects().iter() {
        if let Some(t) = obj.as_text_object() {
            let raw = t.text();
            let s = sanitize_text(&t.text());
            let s = s.trim().to_string();
            if s.is_empty() {
                continue;
            }


            if let Ok(b) = t.bounds() {
                let x0 = b.left().value;
                let x1 = b.right().value;
                let y0 = b.bottom().value;
                let y1 = b.top().value;
                let font_size = t.scaled_font_size().value;

                out.push(TextItem {
                    text: s,
                    x0,
                    y0,
                    x1,
                    y1,
                    font_size,
                });
            }
        }
    }

    out
}


fn collect_line_segs(page: &PdfPage) -> Vec<LineSeg> {
    let mut out = Vec::new();

    for obj in page.objects().iter() {
        if let Some(p) = obj.as_path_object() {
            if let Ok(b) = p.bounds() {
                let x0 = b.left().value;
                let x1 = b.right().value;
                let y0 = b.bottom().value;
                let y1 = b.top().value;

                let w = (x1 - x0).abs();
                let h = (y1 - y0).abs();

                if w > 30.0 && h < 3.0 {
                    out.push(LineSeg { x0, y0: (y0 + y1) * 0.5, x1, y1: (y0 + y1) * 0.5 });
                } else if h > 20.0 && w < 3.0 {
                    out.push(LineSeg { x0: (x0 + x1) * 0.5, y0, x1: (x0 + x1) * 0.5, y1 });
                }
            }
        }
    }

    out
}

fn detect_table_grid(line_segs: &[LineSeg]) -> Option<TableGrid> {
    if line_segs.len() < 4 {
        return None;
    }

    let hor_tol = 3.0;
    let ver_tol = 3.0;

    let horizontals: Vec<&LineSeg> = line_segs.iter().filter(|s| s.is_horizontal(hor_tol)).collect();
    let verticals: Vec<&LineSeg> = line_segs.iter().filter(|s| s.is_vertical(ver_tol)).collect();

    // Potrzebujemy przynajmniej 3 poziomych (góra, dół + 1 separator) i 1 pionowej
    if horizontals.len() < 3 || verticals.len() < 1 {
        return None;
    }

    // Znajdź główną tabelę - linie o podobnej długości
    let h_lengths: Vec<f32> = horizontals.iter().map(|s| (s.x1 - s.x0).abs()).collect();
    let avg_h_len = h_lengths.iter().sum::<f32>() / h_lengths.len() as f32;

    // Filtruj linie poziome - tylko te które są co najmniej 70% średniej długości
    let h_main: Vec<&LineSeg> = horizontals
        .iter()
        .filter(|s| {
            let len = (s.x1 - s.x0).abs();
            len >= avg_h_len * 0.7
        })
        .copied()
        .collect();

    if h_main.len() < 3 {
        return None;
    }

    // Zbierz pozycje X i Y
    let mut xs: Vec<f32> = Vec::new();
    let mut ys: Vec<f32> = Vec::new();

    // Dodaj pionowe linie
    for v in &verticals {
        xs.push(v.x0);
    }

    // Dodaj granice i pozycje z poziomych
    for h in &h_main {
        xs.push(h.x0);
        xs.push(h.x1);
        ys.push(h.y0);
    }

    xs = approx_dedup_sorted(xs, 10.0);
    ys = approx_dedup_sorted(ys, 5.0);

    if xs.len() < 2 || ys.len() < 3 {
        return None;
    }

    // Ograniczenie kolumn - max 6 dla typowych tabel
    if xs.len() > 7 {
        return None;
    }

    let min_x = *xs.first().unwrap();
    let max_x = *xs.last().unwrap();
    let min_y = *ys.first().unwrap();
    let max_y = *ys.last().unwrap();

    let width = max_x - min_x;
    let height = max_y - min_y;

    // Tabela musi mieć sensowny rozmiar
    if width < 150.0 || height < 60.0 {
        return None;
    }

    // Wysokość nie powinna być zbyt duża dla pojedynczej tabeli
    if height > 500.0 {
        return None;
    }

    Some(TableGrid { x_lines: xs, y_lines: ys, min_x, max_x, min_y, max_y })
}

fn group_text_into_lines(items: &[TextItem], y_band: f32) -> Vec<Vec<TextItem>> {
    let mut map: BTreeMap<i32, Vec<TextItem>> = BTreeMap::new();

    for it in items {
        let key = (it.cy() / y_band).round() as i32;
        map.entry(key).or_default().push(it.clone());
    }

    let mut lines: Vec<(i32, Vec<TextItem>)> = map.into_iter().collect();
    lines.sort_by(|a, b| b.0.cmp(&a.0));

    for (_, line) in &mut lines {
        line.sort_by(|a, b| a.x0.partial_cmp(&b.x0).unwrap());
    }

    lines.into_iter().map(|(_, v)| v).collect()
}

fn is_inside_table(line: &[TextItem], grid: &TableGrid) -> bool {
    if line.is_empty() {
        return false;
    }

    // Sprawdź czy większość tekstu jest w granicach X tabeli
    let mut inside_x = 0usize;
    let mut inside_full = 0usize;

    for it in line {
        let cx = it.cx();
        let cy = it.cy();

        // Czy w zakresie X?
        if cx >= grid.min_x - 5.0 && cx <= grid.max_x + 5.0 {
            inside_x += 1;

            // Czy też w zakresie Y?
            if cy >= grid.min_y - 15.0 && cy <= grid.max_y + 15.0 {
                inside_full += 1;
            }
        }
    }

    // Musi być w X i przynajmniej częściowo w Y
    inside_x >= ((line.len() as f32) * 0.7) as usize &&
        inside_full >= ((line.len() as f32) * 0.5) as usize
}

fn assign_to_columns(line: &[TextItem], grid: &TableGrid) -> Vec<String> {
    let col_count = grid.x_lines.len().saturating_sub(1);
    if col_count == 0 {
        return vec![line.iter().map(|t| t.text.as_str()).collect::<Vec<_>>().join(" ")];
    }

    let mut cols: Vec<Vec<&TextItem>> = vec![Vec::new(); col_count];

    for it in line {
        let cx = it.cx();

        // Przypisz do kolumny zawierającej punkt
        let mut assigned = false;
        for i in 0..col_count {
            let left = grid.x_lines[i];
            let right = grid.x_lines[i + 1];

            if cx >= left - 3.0 && cx < right + 3.0 {
                cols[i].push(it);
                assigned = true;
                break;
            }
        }

        // Jeśli nie pasuje, znajdź najbliższą kolumnę
        if !assigned {
            let mut best_idx = 0;
            let mut best_dist = f32::INFINITY;

            for i in 0..col_count {
                let left = grid.x_lines[i];
                let right = grid.x_lines[i + 1];
                let center = (left + right) * 0.5;
                let dist = (cx - center).abs();

                if dist < best_dist {
                    best_dist = dist;
                    best_idx = i;
                }
            }

            cols[best_idx].push(it);
        }
    }

    cols.into_iter()
        .map(|mut cell| {
            cell.sort_by(|a, b| a.x0.partial_cmp(&b.x0).unwrap());
            let s = cell
                .into_iter()
                .map(|t| t.text.as_str())
                .collect::<Vec<_>>()
                .join(" ");
            s.trim().to_string()
        })
        .collect()
}
fn line_to_plain_with_footnote_refs(
    line: &[TextItem],
    body_font: f32,
    referenced: &mut std::collections::BTreeMap<String, usize>, // id -> count
) -> String {
    if line.is_empty() {
        return String::new();
    }

    let mut items = line.to_vec();
    items.sort_by(|a, b| a.x0.partial_cmp(&b.x0).unwrap());

    // mediana cy linii (baseline-ish)
    let mut cys: Vec<f32> = items.iter().map(|t| t.cy()).collect();
    cys.sort_by(|a, b| a.partial_cmp(b).unwrap());
    let line_median_cy = cys[cys.len() / 2];

    fn is_open_punct(ch: char) -> bool {
        matches!(ch, '(' | '[' | '{' | '„' | '"')
    }
    fn is_close_punct(ch: char) -> bool {
        matches!(ch, ')' | ']' | '}' | '”' | '"')
    }
    fn is_sticky_left(ch: char) -> bool {
        matches!(ch, '.' | ',' | ':' | ';' | '!' | '?' | '%' )
    }
    fn is_wordish(ch: char) -> bool {
        ch.is_ascii_digit() || ch.is_alphabetic()
    }

    let mut out = String::new();
    let mut prev: Option<TextItem> = None;

    for it in items.into_iter() {
        let mut t = it.text.trim().to_string();
        if t.is_empty() {
            continue;
        }
        t = t.split_whitespace().collect::<Vec<_>>().join(" ");

        // jeśli to superscript marker (cyfra/*) - dolep jako footnote ref i NIE traktuj jako normalny token
        if let Some(p) = &prev {
            if is_probable_superscript_marker(&it, p, line_median_cy, body_font) {
                let id = normalize_footnote_id(&t);
                *referenced.entry(id.clone()).or_insert(0) += 1;
                out.push_str(&format_footnote_ref(&id));
                // nie zmieniamy `prev` – marker jest przyklejony do poprzedniego tokena
                continue;
            }
        }

        // normalne klejenie tokenów (Twoja logika spacing)
        if let Some(p) = &prev {
            let gap = it.x0 - p.x1;

            let prev_len = p.text.chars().count().max(1) as f32;
            let prev_w = (p.x1 - p.x0).abs().max(1.0);
            let avg_char_w = (prev_w / prev_len).max(0.8);

            let mut space_thr = (avg_char_w * 0.30).max(p.font_size * 0.10).max(0.9);
            if space_thr > 3.2 { space_thr = 3.2; }

            let first_ch = t.chars().next().unwrap_or(' ');
            let last_prev_ch = p.text.chars().last().unwrap_or(' ');

            let mut add_space = gap > space_thr;

            if is_wordish(last_prev_ch) && is_wordish(first_ch) {
                add_space = gap > (space_thr * 0.70);
            }

            if is_sticky_left(first_ch) || is_close_punct(first_ch) {
                add_space = false;
            }
            if is_open_punct(last_prev_ch) {
                add_space = false;
            }

            if add_space && !out.ends_with(' ') {
                out.push(' ');
            }
        }

        out.push_str(&t);
        prev = Some(it);
    }

    out = out.trim().to_string();
    out.split_whitespace().collect::<Vec<_>>().join(" ")
}

fn line_bottom_cy(line: &[TextItem]) -> f32 {
    // minimalny cy (bliżej dołu strony) albo średnia — tu bierzemy medianę
    let mut cys: Vec<f32> = line.iter().map(|t| t.cy()).collect();
    if cys.is_empty() { return 0.0; }
    cys.sort_by(|a,b| a.partial_cmp(b).unwrap());
    cys[cys.len()/2]
}

fn line_avg_font(line: &[TextItem]) -> f32 {
    if line.is_empty() { return 0.0; }
    line.iter().map(|t| t.font_size).sum::<f32>() / line.len() as f32
}

fn try_parse_footnote_definition_start(line: &[TextItem], body_font: f32, page_height: f32) -> Option<(String, String)> {
    if line.is_empty() { return None; }

    let cy = line_bottom_cy(line);
    if cy > page_height * 0.18 {
        return None; // nie dół strony
    }

    let avg_font = line_avg_font(line);
    if avg_font > body_font * 0.98 {
        return None; // zbyt duża czcionka jak na przypis
    }

    // posortuj po x
    let mut items = line.to_vec();
    items.sort_by(|a,b| a.x0.partial_cmp(&b.x0).unwrap());

    // pierwszy token jako marker: "1" albo "*"
    let first = items.first()?.text.trim().to_string();
    if !is_footnote_marker_str(&first) {
        return None;
    }

    let id = normalize_footnote_id(&first);

    // reszta tekstu
    let rest = items[1..]
        .iter()
        .map(|t| t.text.as_str())
        .collect::<Vec<_>>()
        .join(" ");

    let rest = sanitize_text(&rest).trim().to_string();
    if rest.is_empty() {
        return None;
    }

    Some((id, rest))
}

fn is_probable_footnote_continuation(line: &[TextItem], body_font: f32, page_height: f32) -> bool {
    if line.is_empty() { return false; }

    let cy = line_bottom_cy(line);
    if cy > page_height * 0.18 {
        return false;
    }

    let avg_font = line_avg_font(line);
    if avg_font > body_font * 0.98 {
        return false;
    }

    // nie może zaczynać się od nowego markera
    let mut items = line.to_vec();
    items.sort_by(|a,b| a.x0.partial_cmp(&b.x0).unwrap());
    let first = items.first().unwrap().text.trim();
    !is_footnote_marker_str(first)
}


fn should_join_broken_word(prev_line: &str, curr_line: &str) -> bool {
    let prev = prev_line.trim_end();
    let curr = curr_line.trim_start();
    if prev.is_empty() || curr.is_empty() {
        return false;
    }

    // pobierz ostatnie słowo prev i pierwsze słowo curr
    let prev_last = prev.split_whitespace().last().unwrap_or("");
    let curr_first = curr.split_whitespace().next().unwrap_or("");

    if prev_last.is_empty() || curr_first.is_empty() {
        return false;
    }

    // Nie łącz jeśli poprzednia linia kończy się kropką/itd.
    if let Some(last) = prev.chars().last() {
        if matches!(last, '.' | ',' | ':' | ';' | '!' | '?' | ')' | ']' | '}' ) {
            return false;
        }
    }

    // Kluczowa reguła #1:
    // NIE łącz, jeśli pierwsze słowo kolejnej linii jest krótkie (w/i/z/a/o…)
    // bo to robi "informacjiw".
    if curr_first.chars().count() < 3 {
        return false;
    }

    let prev_last_ch = prev_last.chars().last().unwrap_or(' ');
    let curr_first_ch = curr_first.chars().next().unwrap_or(' ');

    // Kluczowa reguła #2 (Twoja):
    // NIE łącz, jeśli kolejna linia zaczyna się Wielką Literą.
    // Wyjątek: dzielenie wyrazu myślnikiem na końcu poprzedniej linii.
    if prev.ends_with('-') {
        // jeśli było dzielenie wyrazu, łącz mimo wielkiej litery (np. nazwy własne dzielone w PDF)
        // ale tylko gdy pierwszy znak po '-' jest literą
        return curr_first_ch.is_alphabetic();
    }

    if curr_first_ch.is_uppercase() {
        return false;
    }

    // Bez myślnika łączymy tylko jeśli wygląda jak urwany wyraz (litera + litera)
    if !prev_last_ch.is_alphabetic() || !curr_first_ch.is_alphabetic() {
        return false;
    }

    // dodatkowe ograniczenie długości, żeby nie sklejać skrótów / tytułów
    let pl = prev_last.chars().count();
    let cl = curr_first.chars().count();
    if pl < 3 || pl > 20 || cl > 20 {
        return false;
    }

    true
}

fn join_broken_word(prev_line: &str, curr_line: &str) -> String {
    let prev = prev_line.trim_end();
    let curr = curr_line.trim_start();

    if prev.ends_with('-') {
        let prev2 = prev.trim_end_matches('-');
        return format!("{}{}", prev2, curr);
    }

    format!("{}{}", prev, curr)
}

fn is_footnote_marker_str(s: &str) -> bool {
    let t = s.trim();
    if t == "*" {
        return true;
    }
    !t.is_empty() && t.chars().all(|c| c.is_ascii_digit()) && t.len() <= 3
}

// markdown footnote id musi być stabilny; "*" mapujemy na "asterisk"
fn normalize_footnote_id(marker: &str) -> String {
    if marker.trim() == "*" {
        "asterisk".to_string()
    } else {
        marker.trim().to_string()
    }
}

fn format_footnote_ref(id: &str) -> String {
    format!("[^{}]", id)
}

fn format_footnote_def(id: &str, text: &str) -> String {
    format!("[^{}]: {}", id, text.trim())
}

fn is_probable_superscript_marker(
    it: &TextItem,
    prev: &TextItem,
    line_median_cy: f32,
    body_font: f32,
) -> bool {
    // marker musi być prosty
    if !is_footnote_marker_str(&it.text) {
        return false;
    }

    // zwykle mniejsza czcionka niż body
    if it.font_size > body_font * 0.95 {
        return false;
    }

    // musi być „wyżej” niż baseline linii
    // (w PDF Y rośnie do góry, więc większe cy = wyżej)
    if it.cy() < line_median_cy + (prev.font_size * 0.10) {
        return false;
    }

    // musi stać tuż po poprzednim tokenie (mała przerwa)
    let gap = it.x0 - prev.x1;
    if gap < -1.0 {
        return false;
    }
    if gap > (prev.font_size * 0.60).max(3.0) {
        return false;
    }

    // poprzedni token powinien wyglądać jak „słowo” (żeby nie łapać gwiazdek dekoracyjnych)
    let prev_last = prev.text.chars().last().unwrap_or(' ');
    let ok_prev = prev_last.is_alphabetic() || prev_last.is_ascii_digit();
    ok_prev
}


fn render_table_row_md(cols: &[String]) -> String {
    let esc = |s: &str| s.replace('|', "\\|").replace('\n', " ");
    let cells = cols.iter().map(|c| esc(c)).collect::<Vec<_>>();
    format!("| {} |", cells.join(" | "))
}

fn is_heading_line(line: &[TextItem], body_font_guess: f32) -> Option<usize> {
    if line.is_empty() {
        return None;
    }

    let avg = line.iter().map(|t| t.font_size).sum::<f32>() / line.len() as f32;

    if avg >= body_font_guess * 1.5 {
        Some(1)
    } else if avg >= body_font_guess * 1.3 {
        Some(2)
    } else if avg >= body_font_guess * 1.15 {
        Some(3)
    } else {
        None
    }
}

fn guess_body_font(items: &[TextItem]) -> f32 {
    let mut v: Vec<f32> = items.iter().map(|t| t.font_size).collect();
    if v.is_empty() {
        return 12.0;
    }
    v.sort_by(|a, b| a.partial_cmp(b).unwrap());
    v[v.len() / 2].max(9.0)
}
fn is_table_marker_line(s: &str) -> bool {
    let t = s.trim();
    t.starts_with("Tabela 1") || t.starts_with("Tabela 2") || t.starts_with("Tabela 3")
}

fn looks_like_group_header(s: &str) -> bool {
    // "GRUPA L 5G / PLAY L 5G"
    let l = s.to_lowercase();
    l.contains("grupa") && l.contains("play")
}
fn looks_like_lp_header(s: &str) -> bool {
    // "LP." i "Taryfa / oferta" bywają rozrzucone na 1–2 linie
    let l = s.to_lowercase();
    (l.contains("lp") || l.contains("lp.")) && (l.contains("taryfa") || l.contains("oferta"))
}

fn starts_with_lp_number(s: &str) -> Option<String> {
    // "2." "3." "5." -> "2" "3" "5"
    let first = s.split_whitespace().next()?;
    if first.ends_with('.') {
        let n = first.trim_end_matches('.');
        if !n.is_empty() && n.chars().all(|c| c.is_ascii_digit()) {
            return Some(n.to_string());
        }
    }
    None
}
fn extract_plus_headers_from_line(plain: &str) -> Vec<String> {
    extract_money_like_tokens(plain)
        .into_iter()
        .filter(|t| t.starts_with("(+"))
        .collect()
}

fn extract_zl_values_from_line(plain: &str) -> Vec<String> {
    extract_money_like_tokens(plain)
        .into_iter()
        .filter(|t| t.ends_with("zł"))
        .collect()
}

// Tekst "opisowy" z linii: usuwa LP, (+..), ceny "xx zł"
fn strip_table_meta_from_text(plain: &str) -> String {
    let mut toks: Vec<&str> = plain.split_whitespace().collect();

    // jeśli na początku jest "2." -> zdejmij
    if let Some(first) = toks.first().copied() {
        if first.ends_with('.') && first.trim_end_matches('.').chars().all(|c| c.is_ascii_digit()) {
            toks.remove(0);
        }
    }

    let mut out: Vec<String> = Vec::new();
    let mut i = 0usize;
    while i < toks.len() {
        let t = toks[i].trim();

        // (+10)
        if t.starts_with("(+") && t.ends_with(')') {
            i += 1;
            continue;
        }

        // liczba + zł
        if t.chars().all(|c| c.is_ascii_digit()) {
            if i + 1 < toks.len() && normalize_zl(toks[i + 1]) == Some("zł") {
                i += 2;
                continue;
            }
        }

        // same "zł" / "zl"
        if normalize_zl(t) == Some("zł") {
            i += 1;
            continue;
        }

        out.push(t.to_string());
        i += 1;
    }

    sanitize_text(&out.join(" ")).trim().to_string()
}

fn is_plus_header_line(plain: &str) -> bool {
    extract_plus_headers_from_line(plain).len() >= 6
}

fn is_value_line_for_width(plain: &str, target_cols: usize) -> bool {
    let zl_cnt = extract_zl_values_from_line(plain).len();
    if zl_cnt == 0 {
        return false;
    }
    // 60% kolumn lub minimum 3 kwoty
    let need = ((target_cols as f32) * 0.6).ceil() as usize;
    zl_cnt >= need.max(3)
}

fn is_single_value_line(plain: &str) -> bool {
    extract_zl_values_from_line(plain).len() == 1
}
fn line_to_plain(line: &[TextItem]) -> String {
    if line.is_empty() {
        return String::new();
    }

    let mut items = line.to_vec();
    items.sort_by(|a, b| a.x0.partial_cmp(&b.x0).unwrap());

    fn is_open_punct(ch: char) -> bool {
        matches!(ch, '(' | '[' | '{' | '„' | '"')
    }
    fn is_close_punct(ch: char) -> bool {
        matches!(ch, ')' | ']' | '}' | '”' | '"')
    }
    fn is_sticky_left(ch: char) -> bool {
        // bez spacji przed tym znakiem
        matches!(ch, '.' | ',' | ':' | ';' | '!' | '?' | '%' )
    }

    fn is_wordish(ch: char) -> bool {
        ch.is_ascii_digit() || ch.is_alphabetic()
    }

    let mut out = String::new();
    let mut prev: Option<TextItem> = None;

    for it in items.into_iter() {
        let mut t = it.text.trim().to_string();
        if t.is_empty() {
            continue;
        }
        t = t.split_whitespace().collect::<Vec<_>>().join(" ");

        if let Some(p) = &prev {
            let gap = it.x0 - p.x1;

            // średnia szerokość znaku poprzedniego tokena
            let prev_len = p.text.chars().count().max(1) as f32;
            let prev_w = (p.x1 - p.x0).abs().max(1.0);
            let avg_char_w = (prev_w / prev_len).max(0.8);

            // Próg spacji: BARDZIEJ agresywnie dodajemy spacje (żeby nie sklejać słów)
            // clamp, żeby nie wariowało na skrajnych fontach
            let mut space_thr = (avg_char_w * 0.30).max(p.font_size * 0.10).max(0.9);
            if space_thr > 3.2 { space_thr = 3.2; }

            let first_ch = t.chars().next().unwrap_or(' ');
            let last_prev_ch = p.text.chars().last().unwrap_or(' ');

            // bazowo: wstaw spację jeśli gap > threshold
            let mut add_space = gap > space_thr;

            // Jeżeli oba tokeny wyglądają jak "słowa" (litery/cyfry), to jesteśmy bardziej skłonni dodać spację
            // nawet przy mniejszym gap (pdfium często daje małe odstępy).
            if is_wordish(last_prev_ch) && is_wordish(first_ch) {
                add_space = gap > (space_thr * 0.70);
            }

            // Reguły interpunkcyjne
            if is_sticky_left(first_ch) || is_close_punct(first_ch) {
                add_space = false;
            }
            if is_open_punct(last_prev_ch) {
                add_space = false;
            }

            if add_space && !out.ends_with(' ') {
                out.push(' ');
            }
        }

        out.push_str(&t);
        prev = Some(it);
    }

    out = out.trim().to_string();
    out.split_whitespace().collect::<Vec<_>>().join(" ")
}

fn try_render_price_table_block(
    out: &mut BufWriter<File>,
    lines: &[Vec<TextItem>],
    start_idx: usize,
) -> Option<usize> {
    let mut i = start_idx;

    // 0) tytuł tabeli jako heading
    let title = line_to_plain(&lines[i]);
    writeln!(out, "\n### {}\n", title.trim()).ok()?;
    i += 1;

    // 1) PREAMBLE:
    // - group header: "GRUPA ... PLAY ..."
    // - col2 header: "Taryfa / oferta" (może być w osobnej linii)
    // - plus header row (wiersz 1 tabeli): zawiera (+10)... oraz opis lewego nagłówka ("Pozycja w ... cenniku urządzeń")
    let mut group_header_acc = String::new();
    let mut col2_header = "Taryfa / oferta".to_string();
    let mut left_caption = String::new();
    let mut plus_headers: Vec<String> = Vec::new();

    while i < lines.len() {
        let plain = line_to_plain(&lines[i]);
        if plain.is_empty() {
            i += 1;
            continue;
        }

        // stopki / kolejna tabela
        if is_footer_line(&plain) {
            return None;
        }
        if i != start_idx && is_table_marker_line(&plain) {
            return None;
        }

        // group header
        if looks_like_group_header(&plain) {
            if !group_header_acc.is_empty() {
                group_header_acc.push(' ');
            }
            group_header_acc.push_str(&plain);
            i += 1;
            continue;
        }

        // złap "Taryfa / oferta" jeśli występuje
        {
            let low = plain.to_lowercase();
            if low.contains("taryfa") || low.contains("oferta") {
                // nie nadpisuj jeśli to ewidentnie jakaś długa linia tytułowa
                if plain.len() <= 60 {
                    col2_header = plain.clone();
                }
            }
        }

        // wiersz nagłówka kolumn: (+10)...(+250)
        if is_plus_header_line(&plain) {
            plus_headers = extract_plus_headers_from_line(&plain);

            // to jest klucz: ta sama linia zwykle zawiera "Pozycja w ... cenniku urządzeń" po lewej
            // wyciągnij ją jako left_caption (bez plusów i cen)
            let cap = strip_table_meta_from_text(&plain);
            if !cap.is_empty() {
                left_caption = cap;
            }
            i += 1;
            break;
        }

        // jeśli jeszcze nie trafiliśmy na (+..), idziemy dalej
        i += 1;
    }

    if plus_headers.is_empty() {
        return None;
    }

    // 2) Wypisz grupę nad tabelą
    if !group_header_acc.trim().is_empty() {
        writeln!(out, "**{}**\n", group_header_acc.trim()).ok()?;
    }

    // 3) Header tabeli: LP | Taryfa/oferta (z dopiętym caption) | (+10)...
    let mut header: Vec<String> = Vec::new();
    header.push("LP.".to_string());

    if !left_caption.trim().is_empty() {
        // np. "Taryfa / oferta — Pozycja w cenniku urządzeń"
        header.push(format!("{} — {}", col2_header.trim(), left_caption.trim()));
    } else {
        header.push(col2_header.trim().to_string());
    }

    header.extend(plus_headers.clone());

    writeln!(out, "{}", render_table_row_md(&header)).ok()?;
    writeln!(
        out,
        "|{}|",
        header.iter().map(|_| "---").collect::<Vec<_>>().join("|")
    )
        .ok()?;

    // 4) DATA:
    // Stan: zbieramy LP/Opis aż do linii wartości (wiele "zł" albo single-value)
    let target_cols = plus_headers.len();
    let mut pending_lp: Option<String> = None;
    let mut pending_desc: String = String::new();

    let mut rows_emitted = 0usize;
    let mut dead_lines = 0usize;

    while i < lines.len() {
        let plain = line_to_plain(&lines[i]);
        if plain.is_empty() {
            i += 1;
            continue;
        }

        // twarde stop: stopka / następna tabela
        if is_footer_line(&plain) {
            break;
        }
        if i != start_idx && is_table_marker_line(&plain) {
            break;
        }

        // Po tym jak mamy już jakieś wiersze: generyczne kończenie tabeli
        if rows_emitted >= 1 {
            let looks_like_header = is_plus_header_line(&plain);
            let looks_like_value = is_value_line_for_width(&plain, target_cols) || is_single_value_line(&plain);
            let looks_like_row_start = starts_with_lp_number(&plain).is_some();
            let looks_like_desc = !strip_table_meta_from_text(&plain).is_empty();

            if !(looks_like_header || looks_like_value || looks_like_row_start || looks_like_desc) {
                dead_lines += 1;
                if dead_lines >= 3 {
                    break;
                }
            } else {
                dead_lines = 0;
            }
        }

        // 4a) Linia wartości: dużo kwot albo jedna kwota
        if is_value_line_for_width(&plain, target_cols) || is_single_value_line(&plain) {
            let (rest, lp_opt) = strip_leading_lp_token(&plain);

            // LP: najpierw z tej linii, a jeśli brak to z pending
            let lp = lp_opt.or_else(|| pending_lp.take()).unwrap_or_else(|| "".to_string());

            // wartości
            let mut zl_vals = extract_zl_values_from_line(&plain);

            // opis: preferuj pending_desc; jak pusty, wyciągnij z reszty (bez meta/cen)
            let mut desc = sanitize_text(&pending_desc).trim().to_string();
            if desc.is_empty() {
                let rest_clean = strip_table_meta_from_text(rest);
                desc = rest_clean;
            }
            if desc.is_empty() {
                // awaryjnie: cała linia bez cen
                desc = strip_table_meta_from_text(&plain);
            }

            // zbuduj row
            let mut row: Vec<String> = Vec::with_capacity(2 + target_cols);
            row.push(lp);
            row.push(desc);

            if zl_vals.len() == 1 {
                // wiersz typu "Abonament za usługę Telewizja Play Now: 10 zł" -> rozlej na wszystkie kolumny
                let v = zl_vals.remove(0);
                for _ in 0..target_cols {
                    row.push(v.clone());
                }
            } else {
                if zl_vals.len() > target_cols {
                    zl_vals.truncate(target_cols);
                }
                for v in zl_vals {
                    row.push(v);
                }
                while row.len() < 2 + target_cols {
                    row.push("".to_string());
                }
            }

            if !is_noise_row(&row) {
                writeln!(out, "{}", render_table_row_md(&row)).ok()?;
                rows_emitted += 1;
            }

            // reset pending
            pending_desc.clear();
            pending_lp = None;

            i += 1;
            continue;
        }

        // 4b) Linia startowa wiersza (LP.) bez wartości
        if let Some(lp) = starts_with_lp_number(&plain) {
            pending_lp = Some(lp);
            let (rest, _) = strip_leading_lp_token(&plain);
            let rest_clean = strip_table_meta_from_text(rest);

            if !rest_clean.is_empty() {
                if pending_desc.is_empty() {
                    pending_desc.push_str(&rest_clean);
                } else {
                    pending_desc.push(' ');
                    pending_desc.push_str(&rest_clean);
                }
            }

            i += 1;
            continue;
        }

        // 4c) Linia opisowa (kontynuacja opisu)
        let desc = strip_table_meta_from_text(&plain);
        if !desc.is_empty() {
            // limit długości, żeby nie wciągnąć pół strony w opis przy błędzie
            let max_len = 220usize;
            if pending_desc.is_empty() {
                pending_desc.push_str(&desc);
            } else {
                pending_desc.push(' ');
                pending_desc.push_str(&desc);
            }
            if pending_desc.chars().count() > max_len {
                pending_desc = pending_desc.chars().take(max_len).collect();
            }
        }

        i += 1;
    }

    writeln!(out).ok()?;
    Some(i)
}




fn strip_leading_lp_token(s: &str) -> (&str, Option<String>) {
    let t = s.trim_start();
    let mut it = t.split_whitespace();

    if let Some(first) = it.next() {
        if first.ends_with('.') {
            let n = first.trim_end_matches('.');
            if !n.is_empty() && n.chars().all(|c| c.is_ascii_digit()) {
                let rest = t[first.len()..].trim_start();
                return (rest, Some(n.to_string()));
            }
        }
    }
    (t, None)
}

fn main() -> Result<(), PdfiumError> {
    let pdfium = Pdfium::new(Pdfium::bind_to_library("libpdfium.dylib")?);
    let document = pdfium.load_pdf_from_file("test.pdf", None)?;

    let file = File::create("output2.md").expect("Błąd pliku");
    let mut out = BufWriter::new(file);

    for (page_idx, page) in document.pages().iter().enumerate() {
        writeln!(out, "\n\n---\n## Page {}\n", page_idx + 1).unwrap();

        let text_items = collect_text_items(&page);
        let body_font = guess_body_font(&text_items);

        // wysokość strony (Pdfium: zwykle punkty)
        let page_height = page.height().value;

        // --- przypisy: referencje + definicje (per strona)
        let mut referenced_notes: BTreeMap<String, usize> = BTreeMap::new(); // id -> count
        let mut footnote_defs: BTreeMap<String, Vec<String>> = BTreeMap::new(); // id -> parts
        let mut current_def_id: Option<String> = None;

        let line_segs = collect_line_segs(&page);
        let table_grid = detect_table_grid(&line_segs);

        if let Some(g) = &table_grid {
            writeln!(
                out,
                "> Detected table grid: cols={}, rows={}, bbox=({:.1},{:.1})-({:.1},{:.1})\n",
                g.x_lines.len().saturating_sub(1),
                g.y_lines.len().saturating_sub(1),
                g.min_x,
                g.min_y,
                g.max_x,
                g.max_y
            )
                .unwrap();
        }

        let lines = group_text_into_lines(&text_items, 2.5);

        let mut in_grid_table = false;
        let mut grid_header_written = false;

        // bufor do łączenia urwanych słów między liniami (tylko dla tekstu poza tabelami)
        let mut pending_text_line: Option<String> = None;

        // helper: flush pending tekstu (żeby nie sklejać przez granice bloków)
        let mut flush_pending = |out: &mut BufWriter<File>, pending: &mut Option<String>| {
            if let Some(p) = pending.take() {
                writeln!(out, "{}\n", p).unwrap();
            }
        };

        let mut idx = 0usize;
        while idx < lines.len() {
            let line = lines[idx].clone();

            // --- (A) PRZYPISY: wykryj definicje na dole strony i nie renderuj ich w treści
            if let Some((id, text)) = try_parse_footnote_definition_start(&line, body_font, page_height) {
                // kończymy ewentualny pending tekstu, bo przypisy to osobny blok
                flush_pending(&mut out, &mut pending_text_line);

                current_def_id = Some(id.clone());
                footnote_defs.entry(id).or_default().push(text);
                idx += 1;
                continue;
            }

            if current_def_id.is_some() && is_probable_footnote_continuation(&line, body_font, page_height) {
                // kontynuacja przypisu: bierzemy plain (bez refs)
                let cont = line_to_plain(&line);
                if !cont.trim().is_empty() {
                    let id = current_def_id.clone().unwrap();
                    footnote_defs.entry(id).or_default().push(cont);
                }
                idx += 1;
                continue;
            }

            // jeżeli byliśmy w przypisie, ale linia już nie wygląda jak dół strony, zamknij przypis
            if current_def_id.is_some() {
                let cy = line_bottom_cy(&line);
                if cy > page_height * 0.22 {
                    current_def_id = None;
                }
            }

            // --- (B) NORMALNY TEKST: generujemy plain z wykrywaniem superscript refs
            let plain = line_to_plain_with_footnote_refs(&line, body_font, &mut referenced_notes);

            if plain.is_empty() {
                idx += 1;
                continue;
            }

            // HARD BREAK stopki
            if is_footer_line(&plain) {
                flush_pending(&mut out, &mut pending_text_line);

                if in_grid_table {
                    in_grid_table = false;
                    grid_header_written = false;
                    writeln!(out).unwrap();
                }

                writeln!(out, "{}\n", plain).unwrap();
                idx += 1;
                continue;
            }

            // SPECJALNY BLOK: Tabela 2 / Tabela 3
            if plain.starts_with("Tabela 2") || plain.starts_with("Tabela 3") {
                flush_pending(&mut out, &mut pending_text_line);

                if in_grid_table {
                    in_grid_table = false;
                    grid_header_written = false;
                    writeln!(out).unwrap();
                }

                if let Some(next_idx) = try_render_price_table_block(&mut out, &lines, idx) {
                    idx = next_idx;
                    continue;
                }
                // jeśli nie zadziałał parser specjalny, lecimy dalej normalnie
            }

            // GRID TABLE (jeśli wykryty)
            let is_grid_line = table_grid
                .as_ref()
                .map(|g| is_inside_table(&line, g))
                .unwrap_or(false);

            if is_grid_line {
                flush_pending(&mut out, &mut pending_text_line);

                let g = table_grid.as_ref().unwrap();

                if !in_grid_table {
                    in_grid_table = true;
                    grid_header_written = false;
                    writeln!(out).unwrap();
                }

                let cols = assign_to_columns_clean(&line, g, body_font, &mut referenced_notes, true);


                if is_noise_row(&cols) {
                    idx += 1;
                    continue;
                }

                if !grid_header_written {
                    writeln!(out, "{}", render_table_row_md(&cols)).unwrap();
                    writeln!(
                        out,
                        "|{}|",
                        cols.iter().map(|_| "---").collect::<Vec<_>>().join("|")
                    )
                        .unwrap();
                    grid_header_written = true;
                } else {
                    writeln!(out, "{}", render_table_row_md(&cols)).unwrap();
                }

                idx += 1;
                continue;
            } else if in_grid_table {
                // wychodzimy z tabeli grid
                in_grid_table = false;
                grid_header_written = false;
                writeln!(out).unwrap();
            }

            // Heading / paragraf (POZA tabelami)
            if let Some(level) = is_heading_line(&line, body_font) {
                flush_pending(&mut out, &mut pending_text_line);

                let hashes = match level {
                    1 => "#",
                    2 => "##",
                    _ => "###",
                };
                writeln!(out, "\n{} {}\n", hashes, plain).unwrap();
                idx += 1;
                continue;
            }

            // Zwykła linia tekstu: próbujemy sklejać "rozlicze" + "niowego"
            if let Some(prev) = pending_text_line.take() {
                if should_join_broken_word(&prev, &plain) {
                    let merged = join_broken_word(&prev, &plain);
                    pending_text_line = Some(merged);
                } else {
                    writeln!(out, "{}\n", prev).unwrap();
                    pending_text_line = Some(plain);
                }
            } else {
                pending_text_line = Some(plain);
            }

            idx += 1;
        }

        // koniec strony: flush pending
        if let Some(p) = pending_text_line.take() {
            writeln!(out, "{}\n", p).unwrap();
        }

        if in_grid_table {
            writeln!(out).unwrap();
        }

        // --- (C) przypisy: dopisz na końcu TEJ strony (tylko te, do których były odwołania)
        let mut emitted_any = false;
        for (id, _cnt) in referenced_notes.iter() {
            if let Some(parts) = footnote_defs.get(id) {
                let text = parts.join(" ");
                if !emitted_any {
                    writeln!(out, "\n---\n#### Przypisy\n").unwrap();
                    emitted_any = true;
                }
                writeln!(out, "{}", format_footnote_def(id, &text)).unwrap();
            }
        }
        if emitted_any {
            writeln!(out).unwrap();
        }
    }

    out.flush().unwrap();
    println!("OK: zapisano output2.md");
    Ok(())
}



fn extract_money_like_tokens(plain: &str) -> Vec<String> {
    let toks: Vec<&str> = plain.split_whitespace().collect();
    let mut out: Vec<String> = Vec::new();

    let mut i = 0usize;
    while i < toks.len() {
        let t = toks[i].trim();

        // "(+10)" itp.
        if t.starts_with("(+") && t.ends_with(')') {
            let inner = &t[2..t.len() - 1];
            if !inner.is_empty() && inner.chars().all(|c| c.is_ascii_digit()) {
                out.push(t.to_string());
            }
            i += 1;
            continue;
        }

        // "7 5 zł" -> "75 zł"
        if t.len() == 1 && t.chars().all(|c| c.is_ascii_digit()) {
            if i + 2 < toks.len()
                && toks[i + 1].len() == 1
                && toks[i + 1].chars().all(|c| c.is_ascii_digit())
                && normalize_zl(toks[i + 2]) == Some("zł")
            {
                out.push(format!("{}{} zł", t, toks[i + 1]));
                i += 3;
                continue;
            }
        }

        // "85 zł" / "0 zł"
        if t.chars().all(|c| c.is_ascii_digit()) {
            if i + 1 < toks.len() && normalize_zl(toks[i + 1]) == Some("zł") {
                out.push(format!("{} zł", t));
                i += 2;
                continue;
            }
            // same liczby czasem są w nagłówkach – zostawiamy
            out.push(t.to_string());
            i += 1;
            continue;
        }

        i += 1;
    }

    out
}


fn normalize_zl(tok: &str) -> Option<&'static str> {
    // Pdfium czasem daje "zł" z dziwnymi znakami, ale zwykle tok zaczyna się od "z"
    let t = tok.trim().to_lowercase();
    if t == "zł" || t == "zl" {
        return Some("zł");
    }
    // awaryjnie: "zł." / "zł," / "zł*" itp.
    if t.starts_with("zł") || t.starts_with("zl") {
        return Some("zł");
    }
    None
}

fn cell_text_table(
    cell_items: &mut Vec<&TextItem>,
    body_font: f32,
    referenced: &mut BTreeMap<String, usize>, // zbieranie przypisów z tabel
    drop_superscripts: bool,                  // true => usuń "2", false => zamień na [^2]
) -> String {
    if cell_items.is_empty() {
        return String::new();
    }

    cell_items.sort_by(|a, b| a.x0.partial_cmp(&b.x0).unwrap());

    // baseline komórki: mediana cy z "normalnych" tokenów (nie bardzo małych fontów)
    let mut base_cys: Vec<f32> = cell_items
        .iter()
        .filter(|t| t.font_size >= body_font * 0.80) // normalny tekst/kwota
        .map(|t| t.cy())
        .collect();

    if base_cys.is_empty() {
        // fallback: weź wszystkie cy
        base_cys = cell_items.iter().map(|t| t.cy()).collect();
    }

    if base_cys.is_empty() {
        // ekstremalny przypadek: dalej pusto (teoretycznie niemożliwe przy !cell_items.is_empty(),
        // ale zostawiamy bezpiecznik)
        return String::new();
    }

    base_cys.sort_by(|a, b| a.partial_cmp(b).unwrap());
    let base_cy = base_cys[base_cys.len() / 2];

    let mut out = String::new();
    let mut prev: Option<&TextItem> = None;

    for it in cell_items.iter().copied() {
        let t = it.text.trim();
        if t.is_empty() {
            continue;
        }

        // ---- SUPERSCRIPT DETECTION (typowe "2" w indeksie górnym przy kwocie)
        let is_marker = is_footnote_marker_str(t);

        let looks_like_super = if is_marker {
            let small_font = it.font_size <= body_font * 0.78;
            let higher = it.cy() > base_cy + (body_font * 0.10);
            let close = if let Some(p) = prev {
                let gap = it.x0 - p.x1;
                gap >= -1.0 && gap <= (body_font * 0.80).max(4.0)
            } else {
                false
            };
            small_font && higher && close
        } else {
            false
        };

        if looks_like_super {
            if drop_superscripts {
                // usuń całkiem
            } else {
                let id = normalize_footnote_id(t);
                *referenced.entry(id.clone()).or_insert(0) += 1;
                out.push_str(&format_footnote_ref(&id));
            }
            continue;
        }

        // ---- NORMAL SPACING (prosto: spacja gdy jest sensowna przerwa)
        if let Some(p) = prev {
            let gap = it.x0 - p.x1;
            let need_space = gap > (body_font * 0.20).max(1.2);
            if need_space && !out.ends_with(' ') {
                out.push(' ');
            }
        }

        out.push_str(t);
        prev = Some(it);
    }

    out.split_whitespace().collect::<Vec<_>>().join(" ")
}


fn assign_to_columns_clean(
    line: &[TextItem],
    grid: &TableGrid,
    body_font: f32,
    referenced: &mut BTreeMap<String, usize>,
    drop_superscripts: bool,
) -> Vec<String> {
    let col_count = grid.x_lines.len().saturating_sub(1);

    if col_count == 0 {
        let mut tmp: Vec<&TextItem> = line.iter().collect();
        let s = cell_text_table(&mut tmp, body_font, referenced, drop_superscripts);
        return vec![s];
    }

    let mut cols: Vec<Vec<&TextItem>> = vec![Vec::new(); col_count];

    for it in line {
        let cx = it.cx();

        let mut assigned = false;
        for i in 0..col_count {
            let left = grid.x_lines[i];
            let right = grid.x_lines[i + 1];
            if cx >= left - 3.0 && cx < right + 3.0 {
                cols[i].push(it);
                assigned = true;
                break;
            }
        }

        if !assigned {
            let mut best_idx = 0usize;
            let mut best_dist = f32::INFINITY;

            for i in 0..col_count {
                let left = grid.x_lines[i];
                let right = grid.x_lines[i + 1];
                let center = (left + right) * 0.5;
                let dist = (cx - center).abs();

                if dist < best_dist {
                    best_dist = dist;
                    best_idx = i;
                }
            }
            cols[best_idx].push(it);
        }
    }

    cols.into_iter()
        .map(|mut cell| cell_text_table(&mut cell, body_font, referenced, drop_superscripts))
        .collect()
}


fn is_price_row(plain: &str) -> bool {
    let tokens = extract_money_like_tokens(plain);
    let plus_cnt = tokens.iter().filter(|t| t.starts_with("(+")).count();
    let zl_cnt = tokens.iter().filter(|t| t.ends_with("zł")).count();

    // tabelka cenowa ma dużo (+..) albo dużo "xx zł"
    plus_cnt >= 6 || zl_cnt >= 6
}

==
py

#!/usr/bin/env python3
import argparse
import os
import subprocess
import sys
from pathlib import Path

def run_marker_single(
    input_path: Path,
    output_dir: Path,
    device: str | None,
    force_ocr: bool,
    strip_existing_ocr: bool,
    paginate_output: bool,
    debug: bool,
) -> None:
    if not input_path.exists():
        raise FileNotFoundError(f"Input file not found: {input_path}")
    output_dir.mkdir(parents=True, exist_ok=True)

    cmd = [
        "marker_single",
        str(input_path),
        "--output_format", "markdown",
        "--output_dir", str(output_dir),
    ]

    if force_ocr:
        cmd.append("--force_ocr")
    if strip_existing_ocr:
        cmd.append("--strip_existing_ocr")
    if paginate_output:
        cmd.append("--paginate_output")
    if debug:
        cmd.append("--debug")

    env = os.environ.copy()
    if device:
        # Marker wspiera wymuszenie urządzenia przez TORCH_DEVICE (np. cpu/cuda/mps).
        env["TORCH_DEVICE"] = device

    print("Running:", " ".join(cmd))
    subprocess.run(cmd, check=True, env=env)

def main() -> int:
    p = argparse.ArgumentParser(description="Convert PDF -> Markdown using Datalab Marker (marker_single).")
    p.add_argument("input", help="Path to input PDF")
    p.add_argument("-o", "--out", default="out_marker", help="Output directory (default: out_marker)")
    p.add_argument("--device", choices=["cpu", "cuda", "mps"], default=None,
                   help="Override torch device via TORCH_DEVICE (optional)")
    p.add_argument("--force-ocr", action="store_true", help="Force OCR on all lines/pages")
    p.add_argument("--strip-existing-ocr", action="store_true", help="Strip existing OCR text and re-run OCR")
    p.add_argument("--paginate", action="store_true", help="Add page separators to output")
    p.add_argument("--debug", action="store_true", help="Enable marker debug logs")
    args = p.parse_args()

    run_marker_single(
        input_path=Path(args.input),
        output_dir=Path(args.out),
        device=args.device,
        force_ocr=args.force_ocr,
        strip_existing_ocr=args.strip_existing_ocr,
        paginate_output=args.paginate,
        debug=args.debug,
    )
    print(f"Done. Check: {args.out}")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())

-=> python3 main.py ./tp4.pdf -o ./out_maker --device cpu
