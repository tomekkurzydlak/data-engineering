use quick_xml::events::Event;
use quick_xml::Reader;

#[derive(Debug, Clone)]
struct WordBox {
    x_min: f32,
    y_min: f32,
    x_max: f32,
    y_max: f32,
    text: String,
}

#[derive(Debug, Clone)]
struct LineBox {
    y: f32,
    y_min: f32,
    y_max: f32,
    words: Vec<WordBox>,
}

/// 1) BBOX XHTML -> Vec<WordBox>
fn parse_bbox_xhtml_words(xhtml: &str) -> Result<Vec<WordBox>> {
    let mut reader = Reader::from_str(xhtml);
    reader.config_mut().trim_text(true);

    let mut buf = Vec::new();
    let mut in_word = false;

    // atrybuty bieżącego <word>
    let mut x_min: Option<f32> = None;
    let mut y_min: Option<f32> = None;
    let mut x_max: Option<f32> = None;
    let mut y_max: Option<f32> = None;

    // tekst bieżącego <word>
    let mut text_acc = String::new();

    let mut out: Vec<WordBox> = Vec::new();

    loop {
        match reader.read_event_into(&mut buf) {
            Ok(Event::Start(e)) => {
                if e.name().as_ref() == b"word" {
                    in_word = true;
                    text_acc.clear();

                    x_min = None;
                    y_min = None;
                    x_max = None;
                    y_max = None;

                    for a in e.attributes().with_checks(false) {
                        let a = a.map_err(|e| anyhow!(e))?;
                        let key = a.key.as_ref();
                        let val = a.unescape_value().map_err(|e| anyhow!(e))?;
                        let val_str = val.as_ref();

                        // poppler typowo: xMin/yMin/xMax/yMax
                        match key {
                            b"xMin" => x_min = val_str.parse::<f32>().ok(),
                            b"yMin" => y_min = val_str.parse::<f32>().ok(),
                            b"xMax" => x_max = val_str.parse::<f32>().ok(),
                            b"yMax" => y_max = val_str.parse::<f32>().ok(),
                            _ => {}
                        }
                    }
                }
            }
            Ok(Event::Text(t)) => {
                if in_word {
                    let s = t.unescape().map_err(|e| anyhow!(e))?;
                    if !s.is_empty() {
                        text_acc.push_str(&s);
                    }
                }
            }
            Ok(Event::End(e)) => {
                if e.name().as_ref() == b"word" {
                    in_word = false;

                    // ignoruj puste
                    let text = text_acc.trim().to_string();
                    if !text.is_empty() {
                        // jeśli czegoś brakuje, odpuść ten word (bez paniki)
                        if let (Some(x1), Some(y1), Some(x2), Some(y2)) = (x_min, y_min, x_max, y_max) {
                            out.push(WordBox {
                                x_min: x1,
                                y_min: y1,
                                x_max: x2,
                                y_max: y2,
                                text,
                            });
                        }
                    }

                    text_acc.clear();
                }
            }
            Ok(Event::Eof) => break,
            Err(e) => return Err(anyhow!(e)),
            _ => {}
        }

        buf.clear();
    }

    Ok(out)
}

/// 2) Words -> Lines (heurystyka po yMin)
fn group_words_into_lines(mut words: Vec<WordBox>) -> Vec<LineBox> {
    // sort: y, potem x
    words.sort_by(|a, b| {
        a.y_min
            .partial_cmp(&b.y_min)
            .unwrap_or(std::cmp::Ordering::Equal)
            .then_with(|| a.x_min.partial_cmp(&b.x_min).unwrap_or(std::cmp::Ordering::Equal))
    });

    // tolerancja różnicy w y dla tej samej linii
    let y_tol: f32 = 2.0;

    let mut lines: Vec<LineBox> = Vec::new();

    for w in words {
        // spróbuj dopasować do ostatniej linii (najczęstszy przypadek)
        if let Some(last) = lines.last_mut() {
            if (w.y_min - last.y_min).abs() <= y_tol {
                last.y_min = last.y_min.min(w.y_min);
                last.y_max = last.y_max.max(w.y_max);
                last.y = (last.y_min + last.y_max) / 2.0;
                last.words.push(w);
                continue;
            }
        }

        // nowa linia
        lines.push(LineBox {
            y: (w.y_min + w.y_max) / 2.0,
            y_min: w.y_min,
            y_max: w.y_max,
            words: vec![w],
        });
    }

    // sort words w każdej linii po X
    for l in &mut lines {
        l.words.sort_by(|a, b| a.x_min.partial_cmp(&b.x_min).unwrap_or(std::cmp::Ordering::Equal));
    }

    lines
}

/// 3) Lines -> Markdown (akapity na podstawie przerw w y)
fn render_lines_to_markdown(lines: Vec<LineBox>) -> String {
    // próg “pustej linii” = skok w y
    let paragraph_gap: f32 = 10.0;

    let mut out = String::new();
    let mut prev_y: Option<f32> = None;

    for (idx, line) in lines.iter().enumerate() {
        let line_text = line
            .words
            .iter()
            .map(|w| w.text.as_str())
            .collect::<Vec<_>>()
            .join(" ")
            .trim()
            .to_string();

        if line_text.is_empty() {
            continue;
        }

        if let Some(py) = prev_y {
            let gap = (line.y_min - py).abs();
            if gap >= paragraph_gap {
                // nowy akapit
                if !out.ends_with("\n\n") {
                    out.push_str("\n\n");
                }
            } else {
                // kontynuacja - nowa linia w ramach akapitu
                out.push('\n');
            }
        }

        out.push_str(&line_text);
        prev_y = Some(line.y_min);

        // na koniec nie doklejaj agresywnie pustych linii – zostaw kontrolę heurystyce
        if idx == lines.len() - 1 {
            out.push('\n');
        }
    }

    out
}

/// 4) BBOX XHTML -> MD (MVP)
pub fn bbox_xhtml_to_md(xhtml: &str) -> Result<String> {
    let words = parse_bbox_xhtml_words(xhtml)?;
    let lines = group_words_into_lines(words);
    Ok(render_lines_to_markdown(lines))
}
