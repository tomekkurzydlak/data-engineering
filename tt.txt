async fn find_latest_execution(&self, job_name: &str) -> Result<String> {
        let token = self.get_token().await?;
        let url = format!("{}/jobs/{}/executions", self.jobs_base(), job_name);

        let res = self
            .client
            .get(&url)
            .bearer_auth(&token)
            .send()
            .await
            .context("błąd GET executions")?;

        if !res.status().is_success() {
            let status = res.status();
            let txt = res.text().await.unwrap_or_default();
            anyhow::bail!("GET executions HTTP error {}: {}", status, txt);
        }

        let body: Value = res.json().await?;
        let executions = body["executions"]
            .as_array()
            .context("Brak 'executions' w odpowiedzi")?;

        if executions.is_empty() {
            anyhow::bail!("Brak executions dla joba {}", job_name);
        }

        // Weź pierwszą (najnowszą) - API zwraca posortowane po dacie malejąco
        let latest = &executions[0];
        let name = latest["name"]
            .as_str()
            .context("Brak 'name' w execution")?
            .to_string();

        Ok(name)
    }

    /// ✅ POST /jobs/{job}:run – uruchamia Cloud Run Job z payloadem
    /// Zwraca execution_name (nie operation_name!)
    async fn start_job(&self, job_name: &str, json_payload: &Value) -> Result<String> {
        let token = self.get_token().await?;
        let url = format!("{}/jobs/{}:run", self.jobs_base(), job_name);

        info!(%job_name, "Wywołuję Cloud Run Job...");
        let body = serde_json::json!({
            "overrides": {
                "containerOverrides": [{
                    "args": [ serde_json::to_string(json_payload)? ]
                }]
            }
        });

        let res = self
            .client
            .post(&url)
            .bearer_auth(&token)
            .json(&body)
            .send()
            .await
            .context("błąd HTTP POST /run")?;

        if !res.status().is_success() {
            let status = res.status();
            let txt = res.text().await.unwrap_or_default();
            anyhow::bail!("Job execution HTTP error {}: {}", status, txt);
        }

        let body: Value = res.json().await?;
        let operation_name = body["name"]
            .as_str()
            .context("Brak 'name' w odpowiedzi z :run")?
            .to_string();

        info!(%operation_name, "Job wystartował (operation utworzona)");
        
        // Poczekaj chwilę żeby execution została utworzona
        sleep(Duration::from_secs(2)).await;
        
        // Znajdź najnowszą execution tego joba
        let execution_name = self.find_latest_execution(job_name).await?;
        
        info!(%execution_name, "Znaleziono execution do pollowania");
        Ok(execution_name)
    }
