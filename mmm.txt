pub fn postprocess_markdownify(md: &str) -> String {
    let md = remove_stitle_comments(md);
    let md = remove_pdf_fence_markers(&md);
    let md = remove_decorative_blocks(&md);
    let md = normalize_years(&md);
    let md = normalize_currencies(&md);
    let md = normalize_currency_pairs(&md);
    let md = repair_broken_tables(&md);
    mark_headings(&md)
}

pub fn remove_stitle_comments(md: &str) -> String {
    let mut out = String::with_capacity(md.len());
    for line in md.split_inclusive('\n') {
        let t = line.trim();
        if t.starts_with("<!--") && t.contains("S-TITLE:") && t.ends_with("-->") {
            continue;
        }
        out.push_str(line);
    }
    out
}

pub fn remove_pdf_fence_markers(md: &str) -> String {
    let mut out = String::with_capacity(md.len());
    for line in md.split_inclusive('\n') {
        let t = line.trim();
        if t == "```" || t == "```pdf" {
            continue;
        }
        out.push_str(line);
    }
    out
}

pub fn remove_decorative_blocks(md: &str) -> String {
    let lines: Vec<&str> = md.lines().collect();
    let mut out: Vec<String> = Vec::with_capacity(lines.len());

    for i in 0..lines.len() {
        let line = lines[i];
        let trimmed = line.trim();

        if trimmed.is_empty() {
            out.push(String::new());
            continue;
        }

        let prev_empty = i == 0 || lines[i - 1].trim().is_empty();
        let next_empty = i + 1 >= lines.len() || lines[i + 1].trim().is_empty();

        if prev_empty && next_empty && is_decorative_line(trimmed) {
            continue;
        }

        out.push(line.to_string());
    }

    let mut s = out.join("\n");
    if md.ends_with('\n') {
        s.push('\n');
    }
    s
}

pub fn repair_broken_tables(md: &str) -> String {
    let mut in_fence = false;
    let lines: Vec<&str> = md.lines().collect();
    let mut out: Vec<String> = Vec::with_capacity(lines.len());

    for i in 0..lines.len() {
        let line = lines[i];

        let t = line.trim_start();
        if t.starts_with("```") {
            in_fence = !in_fence;
            out.push(line.to_string());
            continue;
        }
        if in_fence {
            out.push(line.to_string());
            continue;
        }

        if is_table_rule_line(line) {
            out.push(line.to_string());
            continue;
        }

        if !has_table_context(&lines, i) {
            out.push(line.to_string());
            continue;
        }

        let line2 = line.chars().map(|c| if c == '│' { '|' } else { c }).collect::<String>();

        if line2.contains('|') {
            let starts = chunk_starts_for_line(&line2, 6, true);
            let pipe_count = line2.chars().filter(|c| *c == '|').count();
            if starts.len().saturating_sub(1) <= pipe_count {
                out.push(line2);
                continue;
            }
            out.push(insert_pipes_at_chunk_starts(&line2, &starts));
            continue;
        }

        let starts = chunk_starts_for_line(&line2, 6, false);
        if starts.len() >= 2 {
            out.push(insert_pipes_at_chunk_starts(&line2, &starts));
        } else {
            out.push(line2);
        }
    }

    let mut s = out.join("\n");
    if md.ends_with('\n') {
        s.push('\n');
    }
    s
}

fn has_table_context(lines: &[&str], idx: usize) -> bool {
    let from = idx.saturating_sub(2);
    let to = usize::min(lines.len(), idx + 3);
    for k in from..to {
        if is_table_rule_line(lines[k]) {
            return true;
        }
    }
    false
}

fn is_table_rule_line(line: &str) -> bool {
    let mut deco = 0usize;
    let mut alnum = 0usize;
    let mut non_ws = 0usize;

    for c in line.chars() {
        if c.is_whitespace() {
            continue;
        }
        non_ws += 1;
        if c.is_ascii_alphanumeric() || c.is_alphabetic() {
            alnum += 1;
            continue;
        }
        if matches!(
            c,
            '─' | '━' | '-' | '—' | '–' | '│' | '┃' | '┼' | '┬' | '┴' | '┌' | '┐' | '└' | '┘' | '├' | '┤'
        ) {
            deco += 1;
        }
    }

    if non_ws == 0 {
        return false;
    }

    deco >= 20 && alnum <= 1
}

fn chunk_starts_for_line(line: &str, min_gap: usize, treat_pipe_as_sep: bool) -> Vec<usize> {
    let mut v: Vec<char> = line.chars().collect();

    for c in &mut v {
        if is_zero_width_or_control(*c) || *c == '\u{00A0}' {
            *c = ' ';
        }
    }

    let mut first = None;
    for (i, c) in v.iter().enumerate() {
        if !is_sep(*c, treat_pipe_as_sep) {
            first = Some(i);
            break;
        }
    }
    let Some(first_idx) = first else { return vec![]; };

    let mut starts = vec![first_idx];
    let mut ws_run = 0usize;

    for i in first_idx..v.len() {
        let c = v[i];
        if is_sep(c, treat_pipe_as_sep) {
            ws_run += 1;
            continue;
        }

        if ws_run >= min_gap {
            starts.push(i);
        }
        ws_run = 0;
    }

    starts
}

fn is_sep(c: char, treat_pipe_as_sep: bool) -> bool {
    if c.is_whitespace() {
        return true;
    }
    if treat_pipe_as_sep && (c == '|' || c == '│') {
        return true;
    }
    false
}

fn insert_pipes_at_chunk_starts(line: &str, starts: &[usize]) -> String {
    let mut v: Vec<char> = line.chars().collect();
    let mut offset: isize = 0;

    for &s0 in starts {
        let pos = s0 as isize + offset;
        if pos < 0 {
            continue;
        }
        let pos = pos as usize;
        if pos >= v.len() {
            continue;
        }

        if pos > 0 && v[pos - 1] == '|' {
            continue;
        }
        if pos > 0 {
            let mut j = pos;
            while j > 0 && v[j - 1].is_whitespace() {
                j -= 1;
            }
            if j > 0 && v[j - 1] == '|' {
                continue;
            }
        }

        if pos == 0 {
            if v[0].is_whitespace() {
                v[0] = '|';
            } else {
                v.insert(0, '|');
                offset += 1;
            }
            continue;
        }

        if v[pos - 1].is_whitespace() {
            v[pos - 1] = '|';
        } else {
            v.insert(pos, '|');
            offset += 1;
        }
    }

    v.into_iter().collect()
}

fn is_decorative_line(s: &str) -> bool {
    if s.is_empty() {
        return false;
    }
    if s.contains('|') {
        return false;
    }
    let mut has_deco = false;
    for c in s.chars() {
        if c.is_ascii_alphanumeric() {
            return false;
        }
        if c.is_alphabetic() {
            return false;
        }
        if matches!(
            c,
            '│' | '─' | '┌' | '┐' | '└' | '┘' | '├' | '┤' | '┬' | '┴' | '┼' | '╭' | '╮' | '╰'
                | '╯' | '╳' | '━' | '┃' | '—' | '–' | '-' 
        ) {
            has_deco = true;
            continue;
        }
        if c.is_whitespace() {
            continue;
        }
        if c == '•' || c == '·' {
            continue;
        }
        return false;
    }
    has_deco
}

pub fn mark_headings(md: &str) -> String {
    let lines: Vec<&str> = md.lines().collect();
    let mut out: Vec<String> = Vec::with_capacity(lines.len());

    for i in 0..lines.len() {
        let raw = lines[i];
        let trimmed_raw = raw.trim();
        if trimmed_raw.is_empty() {
            out.push(String::new());
            continue;
        }

        if trimmed_raw.starts_with("```") || trimmed_raw.starts_with("<!--") {
            out.push(raw.to_string());
            continue;
        }

        let prev_empty = i == 0 || lines[i - 1].trim().is_empty();
        let next_empty = i + 1 >= lines.len() || lines[i + 1].trim().is_empty();

        let norm = normalize_line_for_heading(trimmed_raw);
        if norm.is_empty() {
            out.push(raw.to_string());
            continue;
        }

        let looks_table = raw.contains('|') && !trimmed_raw.starts_with("```");
        if looks_table && has_table_context(&lines, i) {
            out.push(raw.to_string());
            continue;
        }

        let is_heading = if prev_empty && next_empty {
            is_candidate_heading(&norm)
        } else {
            is_candidate_heading_relaxed(&norm)
        };

        if is_heading {
            let lvl = heading_level(&norm);
            out.push(format!("{} {}", lvl, normalize_heading_text(&norm)));
        } else {
            out.push(raw.to_string());
        }
    }

    let mut s = out.join("\n");
    if md.ends_with('\n') {
        s.push('\n');
    }
    s
}

fn normalize_line_for_heading(s: &str) -> String {
    let mut out = String::with_capacity(s.len());
    for c in s.chars() {
        if is_zero_width_or_control(c) {
            continue;
        }
        if c == '\u{00A0}' {
            out.push(' ');
            continue;
        }
        out.push(c);
    }
    collapse_spaces(out.trim())
}

fn is_zero_width_or_control(c: char) -> bool {
    matches!(
        c,
        '\u{200B}' | '\u{200C}' | '\u{200D}' | '\u{2060}' | '\u{FEFF}'
    ) || (c.is_control() && c != '\n' && c != '\r' && c != '\t')
}

fn collapse_spaces(s: &str) -> String {
    let mut out = String::with_capacity(s.len());
    let mut prev_space = false;
    for c in s.chars() {
        let is_space = c.is_whitespace();
        if is_space {
            if !prev_space {
                out.push(' ');
            }
            prev_space = true;
        } else {
            out.push(c);
            prev_space = false;
        }
    }
    out
}

fn heading_level(norm: &str) -> &'static str {
    let len = norm.chars().count();
    if len <= 24 {
        "#"
    } else {
        "##"
    }
}

fn is_candidate_heading(norm: &str) -> bool {
    if norm.chars().count() > 80 {
        return false;
    }
    if norm.ends_with('.') {
        return false;
    }
    if norm.contains("http://") || norm.contains("https://") {
        return false;
    }

    let mut alpha = 0usize;
    let mut upper = 0usize;
    let mut lower = 0usize;

    for c in norm.chars() {
        if c.is_alphabetic() {
            alpha += 1;
            if c.is_uppercase() {
                upper += 1;
            } else if c.is_lowercase() {
                lower += 1;
            }
        }
    }

    if alpha < 3 {
        return false;
    }

    let ratio_upper = upper as f32 / (alpha as f32);
    if ratio_upper < 0.80 {
        return false;
    }

    if lower > 0 && ratio_upper < 0.90 {
        return false;
    }

    true
}

fn is_candidate_heading_relaxed(norm: &str) -> bool {
    if norm.chars().count() > 60 {
        return false;
    }
    if norm.ends_with('.') {
        return false;
    }

    let mut alpha = 0usize;
    let mut upper = 0usize;
    let mut lower = 0usize;

    for c in norm.chars() {
        if c.is_alphabetic() {
            alpha += 1;
            if c.is_uppercase() {
                upper += 1;
            } else if c.is_lowercase() {
                lower += 1;
            }
        }
    }

    if alpha < 3 {
        return false;
    }

    let ratio_upper = upper as f32 / (alpha as f32);

    if ratio_upper >= 0.70 && lower <= 2 {
        return true;
    }

    if ratio_upper >= 0.60 && lower == 0 && norm.contains('/') {
        return true;
    }

    false
}

fn normalize_heading_text(norm: &str) -> String {
    let mut out = String::with_capacity(norm.len());
    let mut prev_space = false;

    for c in norm.chars() {
        if c.is_whitespace() {
            if !prev_space {
                out.push(' ');
            }
            prev_space = true;
            continue;
        }
        prev_space = false;

        if c.is_alphabetic() {
            out.push(c);
        } else if c.is_ascii_digit() || matches!(c, '/' | '-' | '–' | '—' | ':' | '.' ) {
            out.push(c);
        } else if c == 'ł' || c == 'Ł' || c == 'Ż' || c == 'ż' || c == 'Ś' || c == 'ś' || c == 'Ć' || c == 'ć' || c == 'Ń' || c == 'ń' || c == 'Ó' || c == 'ó' || c == 'Ą' || c == 'ą' || c == 'Ę' || c == 'ę' {
            out.push(c);
        } else {
            out.push(' ');
            prev_space = true;
        }
    }

    collapse_spaces(out.trim())
}

pub fn normalize_years(md: &str) -> String {
    let mut out = String::with_capacity(md.len());
    for line in md.split_inclusive('\n') {
        out.push_str(&normalize_years_in_line(line));
    }
    out
}

fn normalize_years_in_line(line: &str) -> String {
    let looks_like_table = line.contains('|') && !line.trim_start().starts_with("```");
    if !looks_like_table {
        return normalize_years_free(line);
    }

    let mut out = String::with_capacity(line.len());
    let mut cell = String::new();
    let mut in_cell = false;

    for ch in line.chars() {
        if ch == '|' {
            if in_cell {
                out.push_str(&normalize_years_cell_preserve_width(&cell));
                cell.clear();
            }
            out.push('|');
            in_cell = true;
        } else {
            if in_cell {
                cell.push(ch);
            } else {
                out.push(ch);
            }
        }
    }

    if in_cell {
        out.push_str(&normalize_years_cell_preserve_width(&cell));
    }

    out
}

fn normalize_years_free(s: &str) -> String {
    let chars: Vec<char> = s.chars().collect();
    let mut out = String::with_capacity(s.len());
    let mut i = 0;

    while i < chars.len() {
        if !chars[i].is_ascii_digit() {
            out.push(chars[i]);
            i += 1;
            continue;
        }

        let start = i;
        let mut j = i;

        while j < chars.len() {
            let c = chars[j];
            if c.is_ascii_alphanumeric() {
                if c.is_ascii_digit() {
                    j += 1;
                    continue;
                } else {
                    break;
                }
            }
            j += 1;
        }

        let segment: String = chars[start..j].iter().collect();
        let digits: String = segment.chars().filter(|c| c.is_ascii_digit()).collect();

        if digits.len() != 4 {
            out.push(chars[i]);
            i += 1;
            continue;
        }

        let year: i32 = match digits.parse() {
            Ok(y) => y,
            Err(_) => {
                out.push(chars[i]);
                i += 1;
                continue;
            }
        };

        if !(2018..=2050).contains(&year) {
            out.push(chars[i]);
            i += 1;
            continue;
        }

        let last_digit_pos = find_last_digit_pos(&chars, start, j).unwrap_or(j.saturating_sub(1));
        if !has_r_within_3(&chars, last_digit_pos) {
            out.push(chars[i]);
            i += 1;
            continue;
        }

        out.push_str(&format!("{} r.", year));
        i = j;
        i = consume_r_suffix(&chars, i, 3);
    }

    out
}

fn normalize_years_cell_preserve_width(cell: &str) -> String {
    let chars: Vec<char> = cell.chars().collect();
    let mut out: Vec<char> = chars.clone();
    let mut i = 0;

    while i < chars.len() {
        if !chars[i].is_ascii_digit() {
            i += 1;
            continue;
        }

        let start = i;
        let mut j = i;

        while j < chars.len() {
            let c = chars[j];
            if c.is_ascii_alphanumeric() {
                if c.is_ascii_digit() {
                    j += 1;
                    continue;
                } else {
                    break;
                }
            }
            j += 1;
        }

        let segment: String = chars[start..j].iter().collect();
        let digits: String = segment.chars().filter(|c| c.is_ascii_digit()).collect();

        if digits.len() != 4 {
            i += 1;
            continue;
        }

        let year: i32 = match digits.parse() {
            Ok(y) => y,
            Err(_) => {
                i += 1;
                continue;
            }
        };

        if !(2018..=2050).contains(&year) {
            i += 1;
            continue;
        }

        let last_digit_pos = find_last_digit_pos(&chars, start, j).unwrap_or(j.saturating_sub(1));
        if !has_r_within_3(&chars, last_digit_pos) {
            i += 1;
            continue;
        }

        let mut replace_end = j;
        replace_end = consume_r_suffix(&chars, replace_end, 3);

        let target_len = replace_end.saturating_sub(start);
        if target_len == 0 {
            i += 1;
            continue;
        }

        let candidates = [
            format!("{} r.", year),
            format!("{} r", year),
            format!("{}r", year),
        ];

        let mut chosen: Option<String> = None;
        for c in candidates.iter() {
            if c.chars().count() <= target_len {
                chosen = Some(c.clone());
                break;
            }
        }

        let Some(mut rep) = chosen else {
            i += 1;
            continue;
        };

        let rep_len = rep.chars().count();
        if rep_len < target_len {
            rep.push_str(&" ".repeat(target_len - rep_len));
        } else if rep_len > target_len {
            rep = rep.chars().take(target_len).collect();
        }

        let rep_chars: Vec<char> = rep.chars().collect();
        for k in 0..target_len {
            out[start + k] = rep_chars[k];
        }

        i = replace_end;
    }

    out.into_iter().collect()
}

pub fn normalize_currencies(md: &str) -> String {
    let mut out = String::with_capacity(md.len());
    for line in md.split_inclusive('\n') {
        out.push_str(&normalize_currencies_in_line(line));
    }
    out
}

pub fn normalize_currency_pairs(md: &str) -> String {
    let mut out = String::with_capacity(md.len());
    for line in md.split_inclusive('\n') {
        out.push_str(&normalize_currency_pairs_in_line(line));
    }
    out
}

fn normalize_currency_pairs_in_line(line: &str) -> String {
    let mut out = String::with_capacity(line.len());
    let mut i = 0;
    let chars: Vec<char> = line.chars().collect();

    while i < chars.len() {
        let c = chars[i];
        if c.is_alphabetic() || c == 'ł' || c == 'Ł' || c == '/' {
            let start = i;
            i += 1;
            while i < chars.len() {
                let c2 = chars[i];
                if c2.is_alphabetic() || c2 == 'ł' || c2 == 'Ł' || c2 == '/' {
                    i += 1;
                } else {
                    break;
                }
            }
            let token: String = chars[start..i].iter().collect();
            out.push_str(&normalize_currency_pair_token(&token));
            continue;
        }

        out.push(c);
        i += 1;
    }

    out
}

fn normalize_currency_pair_token(token: &str) -> String {
    let lower = token.to_lowercase();

    if let Some((left, right)) = split_pair_token(token) {
        let l = left.to_uppercase();
        let r = right.to_uppercase();
        if is_currency_code(&l) && is_currency_code(&r) {
            return format!("{}/{}", l, r);
        }
        return token.to_string();
    }

    if lower.ends_with("zł") || lower.ends_with("zl") {
        let prefix_len = token.chars().count().saturating_sub(2);
        let prefix: String = token.chars().take(prefix_len).collect();
        let code = prefix.to_uppercase();
        if is_currency_code(&code) {
            return format!("{}/PLN", code);
        }
        return token.to_string();
    }

    let letters_only = token.chars().all(|c| c.is_alphabetic());
    if letters_only && token.chars().count() == 6 {
        let left: String = token.chars().take(3).collect();
        let right: String = token.chars().skip(3).take(3).collect();
        let l = left.to_uppercase();
        let r = right.to_uppercase();
        if is_currency_code(&l) && is_currency_code(&r) {
            return format!("{}/{}", l, r);
        }
    }

    token.to_string()
}

fn split_pair_token(token: &str) -> Option<(String, String)> {
    let parts: Vec<&str> = token.split('/').collect();
    if parts.len() != 2 {
        return None;
    }
    let left = parts[0].to_string();
    let mut right = parts[1].to_string();
    let right_lower = right.to_lowercase();
    if right_lower == "zł" || right_lower == "zl" {
        right = "PLN".to_string();
    }
    Some((left, right))
}

fn is_currency_code(s: &str) -> bool {
    matches!(
        s,
        "PLN" | "EUR" | "USD" | "GBP" | "CHF" | "DKK" | "NOK" | "SEK" | "CZK" | "HUF" | "HRK"
    )
}

fn normalize_currencies_in_line(line: &str) -> String {
    let looks_like_table = line.contains('|') && !line.trim_start().starts_with("```");
    if !looks_like_table {
        return normalize_currencies_free(line);
    }

    let mut out = String::with_capacity(line.len());
    let mut cell = String::new();
    let mut in_cell = false;

    for ch in line.chars() {
        if ch == '|' {
            if in_cell {
                out.push_str(&normalize_currencies_cell_preserve_width(&cell));
                cell.clear();
            }
            out.push('|');
            in_cell = true;
        } else {
            if in_cell {
                cell.push(ch);
            } else {
                out.push(ch);
            }
        }
    }

    if in_cell {
        out.push_str(&normalize_currencies_cell_preserve_width(&cell));
    }

    out
}

fn normalize_currencies_free(s: &str) -> String {
    let chars: Vec<char> = s.chars().collect();
    let mut out = String::with_capacity(s.len());
    let mut i = 0;

    while i < chars.len() {
        if !is_currency_letter(chars[i]) && !is_currency_sep(chars[i]) {
            out.push(chars[i]);
            i += 1;
            continue;
        }

        let start = i;
        let mut j = i;

        while j < chars.len() {
            let c = chars[j];
            if c.is_ascii_digit() {
                break;
            }
            if is_currency_letter(c) || is_currency_sep(c) {
                j += 1;
                continue;
            }
            break;
        }

        let segment: String = chars[start..j].iter().collect();
        if let Some(norm) = currency_norm_from_segment(&segment) {
            out.push_str(&norm);
            i = j;
            continue;
        }

        out.push(chars[i]);
        i += 1;
    }

    out
}

fn normalize_currencies_cell_preserve_width(cell: &str) -> String {
    let chars: Vec<char> = cell.chars().collect();
    let mut out: Vec<char> = chars.clone();
    let mut i = 0;

    while i < chars.len() {
        if !is_currency_letter(chars[i]) && !is_currency_sep(chars[i]) {
            i += 1;
            continue;
        }

        let start = i;
        let mut j = i;

        while j < chars.len() {
            let c = chars[j];
            if c.is_ascii_digit() {
                break;
            }
            if is_currency_letter(c) || is_currency_sep(c) {
                j += 1;
                continue;
            }
            break;
        }

        let segment: String = chars[start..j].iter().collect();
        let Some(norm) = currency_norm_from_segment(&segment) else {
            i += 1;
            continue;
        };

        let target_len = j.saturating_sub(start);
        if target_len == 0 {
            i += 1;
            continue;
        }

        let candidates = currency_candidates(&norm);
        let mut chosen: Option<String> = None;
        for cand in candidates {
            if cand.chars().count() <= target_len {
                chosen = Some(cand);
                break;
            }
        }

        let Some(mut rep) = chosen else {
            i += 1;
            continue;
        };

        let rep_len = rep.chars().count();
        if rep_len < target_len {
            rep.push_str(&" ".repeat(target_len - rep_len));
        } else if rep_len > target_len {
            rep = rep.chars().take(target_len).collect();
        }

        let rep_chars: Vec<char> = rep.chars().collect();
        for k in 0..target_len {
            out[start + k] = rep_chars[k];
        }

        i = j;
    }

    out.into_iter().collect()
}

fn is_currency_letter(c: char) -> bool {
    c.is_alphabetic() || c == 'ł' || c == 'Ł'
}

fn currency_candidates(norm: &str) -> Vec<String> {
    if norm == "zł" {
        vec!["zł".to_string(), "zl".to_string(), "PLN".to_string()]
    } else {
        vec![norm.to_string(), norm.to_lowercase()]
    }
}

fn currency_norm_from_segment(segment: &str) -> Option<String> {
    let letters: String = segment
        .chars()
        .filter(|c| c.is_alphabetic() || *c == 'ł' || *c == 'Ł')
        .collect();

    if letters.is_empty() {
        return None;
    }

    let folded = letters.to_lowercase();

    if folded == "zł" || folded == "zl" || folded == "pln" {
        return Some("zł".to_string());
    }

    match folded.as_str() {
        "eur" => Some("EUR".to_string()),
        "usd" => Some("USD".to_string()),
        "gbp" => Some("GBP".to_string()),
        "chf" => Some("CHF".to_string()),
        "czk" => Some("CZK".to_string()),
        "nok" => Some("NOK".to_string()),
        "sek" => Some("SEK".to_string()),
        "dkk" => Some("DKK".to_string()),
        "huf" => Some("HUF".to_string()),
        "jpy" => Some("JPY".to_string()),
        "cad" => Some("CAD".to_string()),
        "aud" => Some("AUD".to_string()),
        _ => None,
    }
}

fn is_currency_sep(c: char) -> bool {
    c.is_whitespace() || c == '-' || c == '_' || c == '.' || c == '/' || c == '—' || c == '–'
}

fn find_last_digit_pos(chars: &[char], start: usize, end: usize) -> Option<usize> {
    for idx in (start..end).rev() {
        if chars[idx].is_ascii_digit() {
            return Some(idx);
        }
    }
    None
}

fn has_r_within_3(chars: &[char], last_digit_pos: usize) -> bool {
    let from = last_digit_pos + 1;
    let to = usize::min(chars.len(), last_digit_pos + 4);
    for k in from..to {
        let c = chars[k];
        if c == 'r' || c == 'R' {
            return true;
        }
    }
    false
}

fn consume_r_suffix(chars: &[char], mut idx: usize, max_chars: usize) -> usize {
    let mut consumed = 0;
    while idx < chars.len() && consumed < max_chars {
        let c = chars[idx];
        if c.is_whitespace() || c == '.' || c == 'r' || c == 'R' {
            idx += 1;
            consumed += 1;
            continue;
        }
        break;
    }
    idx
}
