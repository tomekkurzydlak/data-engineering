async fn get_steps_for_file(&self, file_id: &str) -> Result<Vec<ProcessStep>> {
    let q = r#"select mda_14_proc_unstruct.get_payload_for_dispatcher_file($1)"#;

    let result = self.client.query_one(q, &[&file_id]).await;

    let row = result.with_context(|| {
        format!("DB_FETCH_ERROR: Błąd wykonania procedury get_payload_for_dispatcher_file({file_id})")
    })?;

    let payload_opt: Option<String> = row.get(0);

    let payload_str = match payload_opt {
        Some(s) if !s.trim().is_empty() => s,
        _ => {
            return Err(anyhow::anyhow!(
                "{}: DB zwróciła NULL lub pusty JSON dla file_id={file_id}",
                StepErrorCode::NullJson.as_str()
            ));
        }
    };

    let json: JsonValue = serde_json::from_str(&payload_str).map_err(|e| {
        anyhow::anyhow!(
            "{}: nie mogę sparsować JSON dla file_id={file_id}: {e}",
            StepErrorCode::JsonParse.as_str()
        )
    })?;

    let processes_val = match json.get("processes") {
        Some(v) => v.clone(),
        None => {
            return Err(anyhow::anyhow!(
                "{}: brak pola 'processes' dla file_id={file_id}",
                StepErrorCode::MissingProcesses.as_str()
            ));
        }
    };

    let mut steps: Vec<ProcessStep> = serde_json::from_value(processes_val).map_err(|e| {
        anyhow::anyhow!(
            "{}: błąd parsowania steps dla file_id={file_id}: {e}",
            StepErrorCode::JsonParse.as_str()
        )
    })?;

    if steps.is_empty() {
        return Err(anyhow::anyhow!(
            "{}: DB zwróciła pustą tablicę 'processes' dla file_id={file_id}",
            StepErrorCode::EmptyProcesses.as_str()
        ));
    }

    steps.sort_by_key(|s| s.exec_process_seq);

    Ok(steps)
}


===


/// Zapisuje błąd w DB jako finish_process_f(ERROR, error_code:msg)
async fn fail_step_session(
    &self,
    process_cd: &str,
    error_code: StepErrorCode,
    msg: &str,
) -> Result<()> {
    let Some(db) = &self.db else {
        error!(
            %process_cd,
            code = error_code.as_str(),
            %msg,
            "fail_step_session: brak DB, pomijam zapis błędu"
        );
        return Ok(());
    };

    let file_watcher_id = self.cfg.file_watcher_id.unwrap_or(0);
    let tech_insert_id = self.cfg.tech_insert_id.unwrap_or(0);

    let pid = db
        .init_session(process_cd, file_watcher_id, tech_insert_id)
        .await
        .context("fail_step_session: błąd start_process_f")?;

    let tech_update_id = self
        .cfg
        .tech_update_id
        .or(self.cfg.tech_insert_id)
        .unwrap_or(0);

    let full_error_msg = format!("{}: {}", error_code.as_str(), msg);

    if let Err(e) = db
        .end_session(pid, "ERROR", &full_error_msg, tech_update_id)
        .await
    {
        error!(
            error=?e,
            %pid,
            %process_cd,
            code = error_code.as_str(),
            "fail_step_session: błąd finish_process_f"
        );
    }

    Ok(())
}



===


#[derive(Debug)]
pub enum StepErrorCode {
    NullJson,
    JsonParse,
    MissingProcesses,
    EmptyProcesses,
    DbFetchError,
}

impl StepErrorCode {
    pub fn as_str(&self) -> &'static str {
        match self {
            StepErrorCode::NullJson => "NULL_JSON",
            StepErrorCode::JsonParse => "JSON_PARSE_ERROR",
            StepErrorCode::MissingProcesses => "MISSING_PROCESSES",
            StepErrorCode::EmptyProcesses => "EMPTY_PROCESSES",
            StepErrorCode::DbFetchError => "DB_FETCH_ERROR",
        }
    }
}



===

w proceess_dynamic_task


if !steps_cache.contains_key(file_id) {
    let steps = match db.get_steps_for_file(file_id).await {
        Ok(s) => s,
        Err(e) => {
            let msg = e.to_string();

            // Wyciągamy kod błędu z treści wiadomości:
            let code = if msg.contains("NULL_JSON") {
                StepErrorCode::NullJson
            } else if msg.contains("JSON_PARSE_ERROR") {
                StepErrorCode::JsonParse
            } else if msg.contains("MISSING_PROCESSES") {
                StepErrorCode::MissingProcesses
            } else if msg.contains("EMPTY_PROCESSES") {
                StepErrorCode::EmptyProcesses
            } else {
                StepErrorCode::DbFetchError
            };

            self.fail_step_session("UNKNOWN", code, &msg).await?;

            error!(error=?e, %file_id, "DYNAMIC+ASYNC: błąd get_steps_for_file");
            error_flag.store(true, Ordering::SeqCst);
            remaining_files.fetch_sub(1, Ordering::AcqRel);

            return Err(anyhow::anyhow!(msg));
        }
    };


    ===


    
