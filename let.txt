pub fn detect_table_regions(blocks_sorted_by_y: &[BlockBox]) -> Vec<TableRegion> {
    if blocks_sorted_by_y.len() < 6 {
        return Vec::new();
    }

    // strojenie
    let band_h: f32 = 20.0;
    let x_cluster_tol: f32 = 14.0;

    let min_region_bands: usize = 3;
    let min_cols: usize = 2;

    let max_avg_cell_len: f32 = 190.0;
    let min_multi_col_band_ratio: f32 = 0.70;
    let min_shortish_ratio: f32 = 0.25;

    // margines aby nie gubić krawędzi tabeli
    let region_y_margin: f32 = 10.0;

    // kiedy scalać „kontynuacje”
    let continuation_y_gap: f32 = 26.0;

    // ---- bandy po center_y ----
    let mut bands: std::collections::BTreeMap<i64, Vec<&BlockBox>> = std::collections::BTreeMap::new();
    for b in blocks_sorted_by_y {
        let key = (((b.y_min + b.y_max) * 0.5) / band_h).round() as i64;
        bands.entry(key).or_default().push(b);
    }

    #[derive(Clone)]
    struct BandInfo {
        k: i64,
        y1: f32,
        y2: f32,
        filled_cols: usize,
        avg_cell_len: f32,
        shortish_ratio: f32,
    }

    fn nearest_col(x: f32, cols: &[f32]) -> usize {
        let mut best_i = 0usize;
        let mut best_d = f32::INFINITY;
        for (i, cx) in cols.iter().enumerate() {
            let d = (x - *cx).abs();
            if d < best_d {
                best_d = d;
                best_i = i;
            }
        }
        best_i
    }

    // policz cechy bandów
    let mut band_infos: Vec<(i64, BandInfo, Vec<f32>)> = Vec::new(); // (k, info, col_x)

    for (&k, v) in &bands {
        let mut xs: Vec<f32> = Vec::new();
        let mut y1 = f32::INFINITY;
        let mut y2 = f32::NEG_INFINITY;

        let mut candidates: Vec<(&BlockBox, usize)> = Vec::new();
        for b in v {
            let t = block_text_norm(b);
            let tl = t.trim().len();
            if tl == 0 {
                continue;
            }
            xs.push(b.x_min);
            candidates.push((b, tl));
            y1 = y1.min(b.y_min);
            y2 = y2.max(b.y_max);
        }

        if xs.len() < 2 {
            continue;
        }

        let mut col_x = cluster_xmins(xs, x_cluster_tol);
        col_x.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
        if col_x.len() < min_cols {
            continue;
        }

        let mut col_counts = vec![0usize; col_x.len()];
        let mut cell_lens: Vec<usize> = Vec::new();

        for (b, tl) in &candidates {
            let i = nearest_col(b.x_min, &col_x);
            col_counts[i] += 1;
            cell_lens.push(*tl);
        }

        let filled_cols = col_counts.iter().filter(|c| **c > 0).count();
        if filled_cols < 2 {
            continue;
        }

        let avg_cell_len = cell_lens.iter().sum::<usize>() as f32 / cell_lens.len().max(1) as f32;
        let shortish = cell_lens.iter().filter(|l| **l <= 80).count();
        let shortish_ratio = shortish as f32 / cell_lens.len().max(1) as f32;

        let info = BandInfo {
            k,
            y1: if y1.is_finite() { y1 } else { (k as f32 - 0.5) * band_h },
            y2: if y2.is_finite() { y2 } else { (k as f32 + 0.5) * band_h },
            filled_cols,
            avg_cell_len,
            shortish_ratio,
        };

        band_infos.push((k, info, col_x));
    }

    if band_infos.is_empty() {
        return Vec::new();
    }

    band_infos.sort_by(|a, b| a.0.cmp(&b.0));

    // bandy “tabelowe”
    let mut good: Vec<i64> = Vec::new();
    for (k, info, _cols) in &band_infos {
        let ok = info.filled_cols >= 2 && info.avg_cell_len <= max_avg_cell_len;
        if ok {
            good.push(*k);
        }
    }
    if good.is_empty() {
        return Vec::new();
    }

    // regiony jako ciągi kolejnych bandów
    good.sort();
    let mut regions_k: Vec<(i64, i64)> = Vec::new();
    let mut sk = good[0];
    let mut pk = good[0];
    for &k in good.iter().skip(1) {
        if k == pk + 1 {
            pk = k;
        } else {
            regions_k.push((sk, pk));
            sk = k;
            pk = k;
        }
    }
    regions_k.push((sk, pk));

    // helper: policz ratio regionu
    let band_map: std::collections::HashMap<i64, BandInfo> = band_infos
        .iter()
        .map(|(k, info, _)| (*k, info.clone()))
        .collect();

    // helper: wyznacz y1/y2 regionu
    let region_y = |sk: i64, ek: i64| -> Option<(f32, f32)> {
        let mut y1 = f32::INFINITY;
        let mut y2 = f32::NEG_INFINITY;
        let mut any = false;

        for k in sk..=ek {
            if let Some(bi) = band_map.get(&k) {
                any = true;
                y1 = y1.min(bi.y1);
                y2 = y2.max(bi.y2);
            }
        }
        if !any || !y1.is_finite() || !y2.is_finite() {
            None
        } else {
            Some((y1 - region_y_margin, y2 + region_y_margin))
        }
    };

    // helper: zbuduj kolumny regionu i “przytnij” do dwóch najsilniejszych
    fn refine_region_columns(blocks: &[BlockBox], y1: f32, y2: f32, x_cluster_tol: f32) -> Vec<f32> {
        let mut xs: Vec<f32> = Vec::new();
        for b in blocks {
            if b.y_max < y1 || b.y_min > y2 {
                continue;
            }
            let t = block_text_norm(b);
            if t.trim().is_empty() {
                continue;
            }
            xs.push(b.x_min);
        }
        if xs.len() < 4 {
            return Vec::new();
        }

        let mut cols = cluster_xmins(xs, x_cluster_tol);
        cols.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));

        // policz support
        let mut counts = vec![0usize; cols.len()];
        for b in blocks {
            if b.y_max < y1 || b.y_min > y2 {
                continue;
            }
            let t = block_text_norm(b);
            if t.trim().is_empty() {
                continue;
            }
            let mut best_i = 0usize;
            let mut best_d = f32::INFINITY;
            for (i, cx) in cols.iter().enumerate() {
                let d = (b.x_min - *cx).abs();
                if d < best_d {
                    best_d = d;
                    best_i = i;
                }
            }
            if best_d <= 42.0 {
                counts[best_i] += 1;
            }
        }

        // odrzuć małe klastry
        let max_c = *counts.iter().max().unwrap_or(&0);
        let min_keep = std::cmp::max(3, (max_c as f32 * 0.25) as usize);

        let mut kept: Vec<(f32, usize)> = cols.into_iter().zip(counts.into_iter()).collect();
        kept.retain(|(_, c)| *c >= min_keep);

        if kept.len() < 2 {
            kept.sort_by(|a, b| b.1.cmp(&a.1));
            kept.truncate(2);
        }
        if kept.len() > 2 {
            kept.sort_by(|a, b| b.1.cmp(&a.1));
            kept.truncate(2);
        }

        let mut out: Vec<f32> = kept.into_iter().map(|(x, _)| x).collect();
        out.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
        out
    }

    // z regionów_k zbuduj regiony tabel z filtrami ratio
    let mut regions: Vec<TableRegion> = Vec::new();

    for (sk, ek) in regions_k {
        let band_count = (ek - sk + 1) as usize;
        if band_count < min_region_bands {
            continue;
        }

        let mut bands_in: Vec<BandInfo> = Vec::new();
        for k in sk..=ek {
            if let Some(bi) = band_map.get(&k) {
                bands_in.push(bi.clone());
            }
        }
        if bands_in.is_empty() {
            continue;
        }

        let multi_col = bands_in.iter().filter(|b| b.filled_cols >= 2).count();
        let multi_col_ratio = multi_col as f32 / bands_in.len().max(1) as f32;

        let shortish_ratio_avg = bands_in.iter().map(|b| b.shortish_ratio).sum::<f32>() / bands_in.len().max(1) as f32;

        if multi_col_ratio < min_multi_col_band_ratio {
            continue;
        }
        if shortish_ratio_avg < min_shortish_ratio {
            continue;
        }

        let (y1, y2) = match region_y(sk, ek) {
            Some(v) => v,
            None => continue,
        };

        let col_x = refine_region_columns(blocks_sorted_by_y, y1, y2, x_cluster_tol);
        if col_x.len() < min_cols {
            continue;
        }

        regions.push(TableRegion { y1, y2, col_x });
    }

    if regions.is_empty() {
        return Vec::new();
    }

    // ---- scal “kontynuacje” tabel: bliskie Y i podobne kolumny ----
    regions.sort_by(|a, b| a.y1.partial_cmp(&b.y1).unwrap_or(std::cmp::Ordering::Equal));

    fn cols_similar(a: &[f32], b: &[f32]) -> bool {
        if a.len() != b.len() {
            return false;
        }
        // 2 kolumny: wystarczy, że x są blisko
        for i in 0..a.len() {
            if (a[i] - b[i]).abs() > 24.0 {
                return false;
            }
        }
        true
    }

    let mut merged: Vec<TableRegion> = Vec::new();
    for r in regions {
        if let Some(last) = merged.last_mut() {
            let gap = r.y1 - last.y2;
            if gap <= continuation_y_gap && cols_similar(&last.col_x, &r.col_x) {
                last.y2 = last.y2.max(r.y2);
                // kolumny zostaw z last (stabilniejsze)
            } else {
                merged.push(r);
            }
        } else {
            merged.push(r);
        }
    }

    merged
}
==
pub fn mark_table_blocks(blocks_sorted_by_y: &[BlockBox], regions: &[TableRegion]) -> Vec<bool> {
    let mut mask = vec![false; blocks_sorted_by_y.len()];
    if regions.is_empty() {
        return mask;
    }

    // strojenie: jak daleko w X uznajemy “należy do kolumny”
    let x_assign_tol: f32 = 52.0;

    for (i, b) in blocks_sorted_by_y.iter().enumerate() {
        let txt = block_text_norm(b);
        if txt.trim().is_empty() {
            continue;
        }

        for r in regions {
            // overlap w osi Y
            if b.y_max < r.y1 || b.y_min > r.y2 {
                continue;
            }

            // przypisz do najbliższej kolumny
            let mut best_d = f32::INFINITY;
            for cx in &r.col_x {
                let d = (b.x_min - *cx).abs();
                if d < best_d {
                    best_d = d;
                }
            }

            if best_d <= x_assign_tol {
                mask[i] = true;
                break;
            }
        }
    }

    mask
}
==
fn render_pages_to_md(pages: Vec<PageBox>) -> String {
    let mut out = String::new();

    // notki
    let note_indent_px: f32 = 30.0;
    let attach_max_gap_px: f32 = 90.0;

    for (pi, page) in pages.iter().enumerate() {
        let mut blocks = page.blocks.clone();
        blocks.sort_by(|a, b| a.y_min.partial_cmp(&b.y_min).unwrap_or(std::cmp::Ordering::Equal));

        // 1) regiony tabel
        let table_regions = detect_table_regions(&blocks);

        // 2) maska bloków tabelowych (Y overlap + X-nearest)
        let table_mask = mark_table_blocks(&blocks, &table_regions);

        // 3) render tabel (po regionach) — ważne: render opiera się o te same blocks,
        //    ale do dalszego tekstu NIE przepuszczamy table_mask=true
        for r in &table_regions {
            let tmd = render_table_region_to_md(&blocks, r);
            if !tmd.trim().is_empty() {
                out.push_str(&tmd);
            }
        }

        // 4) non-table
        let mut non_table_blocks: Vec<BlockBox> = Vec::new();
        for (i, b) in blocks.iter().enumerate() {
            if !table_mask[i] {
                non_table_blocks.push(b.clone());
            }
        }

        // 5) tekst + notki tylko na non-table
        if !non_table_blocks.is_empty() {
            non_table_blocks.sort_by(|a, b| a.y_min.partial_cmp(&b.y_min).unwrap_or(std::cmp::Ordering::Equal));

            // body_left na non-table
            let mut xmins: Vec<f32> = non_table_blocks.iter().map(|b| b.x_min).collect();
            xmins.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
            let body_left = xmins.get(xmins.len() / 2).copied().unwrap_or(0.0);

            let (bodies, attachments, loose_notes) =
                attach_notes_to_bodies(&non_table_blocks, body_left, note_indent_px, attach_max_gap_px);

            let mut attached_map: std::collections::BTreeMap<usize, Vec<BlockBox>> =
                std::collections::BTreeMap::new();
            for a in attachments {
                attached_map.entry(a.body_idx).or_default().push(a.note);
            }

            for (bi, body) in bodies.iter().enumerate() {
                if body.lines.is_empty() {
                    continue;
                }

                let mut lines = body.lines.clone();
                lines.sort_by(|a, b| a.y_min.partial_cmp(&b.y_min).unwrap_or(std::cmp::Ordering::Equal));

                let body_txt = render_block_lines_to_md(&lines);
                if !body_txt.trim().is_empty() {
                    out.push_str(body_txt.trim());
                    out.push_str("\n\n");
                }

                if let Some(notes_for_body) = attached_map.get(&bi) {
                    for note in notes_for_body {
                        if note.lines.is_empty() {
                            continue;
                        }
                        let mut nlines = note.lines.clone();
                        nlines.sort_by(|a, b| a.y_min.partial_cmp(&b.y_min).unwrap_or(std::cmp::Ordering::Equal));

                        let note_txt = render_note_block_as_callout(&nlines);
                        if !note_txt.trim().is_empty() {
                            out.push_str(&note_txt);
                        }
                    }
                }
            }

            if !loose_notes.is_empty() {
                out.push('\n');
                for note in loose_notes {
                    if note.lines.is_empty() {
                        continue;
                    }
                    let mut nlines = note.lines.clone();
                    nlines.sort_by(|a, b| a.y_min.partial_cmp(&b.y_min).unwrap_or(std::cmp::Ordering::Equal));

                    let note_txt = render_note_block_as_callout(&nlines);
                    if !note_txt.trim().is_empty() {
                        out.push_str(&note_txt);
                    }
                }
                out.push('\n');
            }
        }

        if pi + 1 < pages.len() {
            out.push_str("\n---\n\n");
        }
    }

    out
}
==
