pub fn detect_table_regions(blocks_sorted_by_y: &[BlockBox]) -> Vec<TableRegion> {
    if blocks_sorted_by_y.len() < 6 {
        return Vec::new();
    }

    // ---- strojenie ----
    let band_h: f32 = 20.0;            // grupowanie wierszy
    let x_cluster_tol: f32 = 14.0;     // tolerancja klastrów kolumn
    let min_region_bands: usize = 3;   // min liczba bandów w regionie
    let min_cols: usize = 2;

    // cechy “tabelowe”
    let max_avg_cell_len: f32 = 170.0;     // tabela porównawcza może mieć dłuższe komórki
    let min_multi_col_band_ratio: f32 = 0.70; // większość bandów ma >=2 kolumny z treścią
    let min_shortish_ratio: f32 = 0.35;    // konserwatywnie (tabele porównawcze mają dłuższe teksty)

    // marginesy Y, żeby nie gubić krawędzi
    let region_y_margin: f32 = 8.0;

    // ---- bandy po center_y ----
    let mut bands: std::collections::BTreeMap<i64, Vec<&BlockBox>> = std::collections::BTreeMap::new();
    for b in blocks_sorted_by_y {
        let key = ((b.y_min + b.y_max) * 0.5 / band_h).round() as i64;
        bands.entry(key).or_default().push(b);
    }

    #[derive(Clone)]
    struct BandInfo {
        k: i64,
        y1: f32,
        y2: f32,
        col_x: Vec<f32>,
        filled_cols: usize,
        avg_cell_len: f32,
        shortish_ratio: f32,
        n_cells: usize,
    }

    // pomocniczo: przypisz do najbliższej kolumny
    fn nearest_col(x: f32, cols: &[f32]) -> usize {
        let mut best_i = 0usize;
        let mut best_d = f32::INFINITY;
        for (i, cx) in cols.iter().enumerate() {
            let d = (x - *cx).abs();
            if d < best_d {
                best_d = d;
                best_i = i;
            }
        }
        best_i
    }

    // ---- policz cechy bandów ----
    let mut infos: Vec<BandInfo> = Vec::new();

    for (&k, v) in &bands {
        let mut xs: Vec<f32> = Vec::new();
        let mut y1 = f32::INFINITY;
        let mut y2 = f32::NEG_INFINITY;

        // weź tylko sensowne tekstowo bloki do budowy klastrów
        let mut candidates: Vec<(&BlockBox, usize)> = Vec::new();
        for b in v {
            let t = block_text_norm(b);
            let tl = t.trim().len();
            if tl == 0 {
                continue;
            }
            xs.push(b.x_min);
            candidates.push((b, tl));
            y1 = y1.min(b.y_min);
            y2 = y2.max(b.y_max);
        }

        if xs.len() < 2 {
            continue;
        }

        let mut col_x = cluster_xmins(xs, x_cluster_tol);
        col_x.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
        if col_x.len() < min_cols {
            continue;
        }

        // policz obsadzenie kolumn i statystyki komórek
        let mut col_counts = vec![0usize; col_x.len()];
        let mut cell_lens: Vec<usize> = Vec::new();

        for (b, tl) in &candidates {
            let i = nearest_col(b.x_min, &col_x);
            col_counts[i] += 1;
            cell_lens.push(*tl);
        }

        let filled_cols = col_counts.iter().filter(|c| **c > 0).count();
        if filled_cols < 2 {
            // w bandzie realnie jest treść tylko w jednej kolumnie => nie jest “wierszem tabeli”
            continue;
        }

        let avg_cell_len = cell_lens.iter().sum::<usize>() as f32 / cell_lens.len().max(1) as f32;
        let shortish = cell_lens.iter().filter(|l| **l <= 80).count();
        let shortish_ratio = shortish as f32 / cell_lens.len().max(1) as f32;

        infos.push(BandInfo {
            k,
            y1: if y1.is_finite() { y1 } else { (k as f32 - 0.5) * band_h },
            y2: if y2.is_finite() { y2 } else { (k as f32 + 0.5) * band_h },
            col_x,
            filled_cols,
            avg_cell_len,
            shortish_ratio,
            n_cells: cell_lens.len(),
        });
    }

    if infos.is_empty() {
        return Vec::new();
    }

    infos.sort_by(|a, b| a.k.cmp(&b.k));

    // ---- wybierz bandy “tabelowe” (kandydaci) ----
    let mut is_table_band: std::collections::HashMap<i64, bool> = std::collections::HashMap::new();
    for bi in &infos {
        let ok = bi.filled_cols >= 2 && bi.avg_cell_len <= max_avg_cell_len;
        is_table_band.insert(bi.k, ok);
    }

    // ---- złącz bandy w regiony ----
    let mut regions_raw: Vec<(i64, i64)> = Vec::new();
    let mut start_k: Option<i64> = None;
    let mut prev_k: i64 = 0;

    for bi in &infos {
        let ok = *is_table_band.get(&bi.k).unwrap_or(&false);
        if ok {
            if start_k.is_none() {
                start_k = Some(bi.k);
                prev_k = bi.k;
            } else if bi.k == prev_k + 1 {
                prev_k = bi.k;
            } else {
                regions_raw.push((start_k.unwrap(), prev_k));
                start_k = Some(bi.k);
                prev_k = bi.k;
            }
        } else if let Some(sk) = start_k.take() {
            regions_raw.push((sk, prev_k));
        }
    }
    if let Some(sk) = start_k.take() {
        regions_raw.push((sk, prev_k));
    }

    // ---- helper: “przytnij” kolumny do tych z realnym supportem ----
    fn refine_columns_by_support(
        blocks: &[BlockBox],
        y1: f32,
        y2: f32,
        mut col_x: Vec<f32>,
        x_tol: f32,
    ) -> Vec<f32> {
        if col_x.len() <= 2 {
            col_x.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
            return col_x;
        }

        col_x.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
        let mut counts = vec![0usize; col_x.len()];

        for b in blocks {
            // overlap Y, nie center
            if b.y_max < y1 || b.y_min > y2 {
                continue;
            }
            let t = block_text_norm(b);
            if t.trim().is_empty() {
                continue;
            }

            // nearest centroid
            let mut best_i = 0usize;
            let mut best_d = f32::INFINITY;
            for (i, cx) in col_x.iter().enumerate() {
                let d = (b.x_min - *cx).abs();
                if d < best_d {
                    best_d = d;
                    best_i = i;
                }
            }
            if best_d <= x_tol {
                counts[best_i] += 1;
            }
        }

        // threshold: odrzuć małe klastry (artefakty)
        let max_c = *counts.iter().max().unwrap_or(&0);
        let min_keep = std::cmp::max(3, (max_c as f32 * 0.25) as usize);

        let mut kept: Vec<(f32, usize)> = col_x.into_iter().zip(counts.into_iter()).collect();
        kept.retain(|(_, c)| *c >= min_keep);

        // jeśli przez przypadek odrzuciliśmy za dużo, zachowaj 2 najmocniejsze
        if kept.len() < 2 {
            kept.sort_by(|a, b| b.1.cmp(&a.1));
            kept.truncate(2);
        }

        // final: jeśli nadal >2, ale tabela w praktyce 2-kolumnowa, wybierz 2 najmocniejsze
        if kept.len() > 2 {
            kept.sort_by(|a, b| b.1.cmp(&a.1));
            kept.truncate(2);
        }

        let mut cols: Vec<f32> = kept.into_iter().map(|(x, _)| x).collect();
        cols.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
        cols
    }

    // ---- final: regiony + filtr ratio ----
    let mut out: Vec<TableRegion> = Vec::new();

    for (sk, ek) in regions_raw {
        let band_count = (ek - sk + 1) as usize;
        if band_count < min_region_bands {
            continue;
        }

        let region_bands: Vec<&BandInfo> = infos.iter().filter(|bi| bi.k >= sk && bi.k <= ek).collect();
        if region_bands.is_empty() {
            continue;
        }

        let multi_col = region_bands.iter().filter(|bi| bi.filled_cols >= 2).count();
        let multi_col_ratio = multi_col as f32 / region_bands.len().max(1) as f32;

        let shortish_ratio_avg =
            region_bands.iter().map(|bi| bi.shortish_ratio).sum::<f32>() / region_bands.len().max(1) as f32;

        if multi_col_ratio < min_multi_col_band_ratio {
            continue;
        }
        if shortish_ratio_avg < min_shortish_ratio {
            continue;
        }

        // y-range regionu: z bandów
        let mut y1 = region_bands.iter().map(|bi| bi.y1).fold(f32::INFINITY, f32::min);
        let mut y2 = region_bands.iter().map(|bi| bi.y2).fold(f32::NEG_INFINITY, f32::max);
        if !y1.is_finite() || !y2.is_finite() {
            continue;
        }
        y1 -= region_y_margin;
        y2 += region_y_margin;

        // centroidy: zbierz x_min w regionie i zaklastruj
        let mut xs: Vec<f32> = Vec::new();
        for b in blocks_sorted_by_y {
            if b.y_max < y1 || b.y_min > y2 {
                continue;
            }
            let t = block_text_norm(b);
            if t.trim().is_empty() {
                continue;
            }
            xs.push(b.x_min);
        }
        if xs.len() < 4 {
            continue;
        }

        let mut col_x = cluster_xmins(xs, x_cluster_tol);
        col_x = refine_columns_by_support(blocks_sorted_by_y, y1, y2, col_x, 42.0);

        if col_x.len() < min_cols {
            continue;
        }

        out.push(TableRegion { y1, y2, col_x });
    }

    // scal bliskie regiony
    out.sort_by(|a, b| a.y1.partial_cmp(&b.y1).unwrap_or(std::cmp::Ordering::Equal));
    let merge_gap = 10.0;

    let mut merged: Vec<TableRegion> = Vec::new();
    for r in out {
        if let Some(last) = merged.last_mut() {
            if r.y1 <= last.y2 + merge_gap {
                last.y2 = last.y2.max(r.y2);

                // merge kolumn i refine jeszcze raz
                let mut xs = last.col_x.clone();
                xs.extend(r.col_x.clone());
                let mut cc = cluster_xmins(xs, 18.0);
                cc.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
                last.col_x = cc;
            } else {
                merged.push(r);
            }
        } else {
            merged.push(r);
        }
    }

    merged
}
===

pub fn render_table_region_to_md(blocks_sorted_by_y: &[BlockBox], region: &TableRegion) -> String {
    // strojenie
    let band_h: f32 = 20.0;
    let y_row_merge_gap: f32 = 6.0; // tolerancja wiersza (gdy bandy lekko pływają)

    if region.col_x.len() < 2 {
        return String::new();
    }

    // 1) wybierz bloki w regionie (overlap Y)
    let mut region_blocks: Vec<&BlockBox> = blocks_sorted_by_y
        .iter()
        .filter(|b| !(b.y_max < region.y1 || b.y_min > region.y2))
        .collect();

    if region_blocks.is_empty() {
        return String::new();
    }

    // 2) sort po Y a potem X
    region_blocks.sort_by(|a, b| {
        a.y_min
            .partial_cmp(&b.y_min)
            .unwrap_or(std::cmp::Ordering::Equal)
            .then_with(|| a.x_min.partial_cmp(&b.x_min).unwrap_or(std::cmp::Ordering::Equal))
    });

    // helper: nearest col
    fn nearest_col(x: f32, cols: &[f32]) -> usize {
        let mut best_i = 0usize;
        let mut best_d = f32::INFINITY;
        for (i, cx) in cols.iter().enumerate() {
            let d = (x - *cx).abs();
            if d < best_d {
                best_d = d;
                best_i = i;
            }
        }
        best_i
    }

    // 3) zbuduj “row keys” stabilniej niż tylko (center_y/band_h)
    //    Użyjemy y_min i będziemy scalać sąsiednie rzędy, jeśli są bardzo blisko
    let mut rows: Vec<(f32, Vec<&BlockBox>)> = Vec::new(); // (row_y, blocks)

    for b in region_blocks {
        let row_y = b.y_min; // lepsze niż center_y dla tabel
        if let Some((last_y, last_vec)) = rows.last_mut() {
            if (row_y - *last_y).abs() <= y_row_merge_gap || (row_y - *last_y).abs() <= band_h * 0.5 {
                last_vec.push(b);
                continue;
            }
        }
        rows.push((row_y, vec![b]));
    }

    // 4) buduj wiersze tabeli jako Vec<String> o len=col_count
    let col_count = region.col_x.len();
    let mut table_rows: Vec<Vec<String>> = Vec::new();

    for (_y, mut bs) in rows {
        bs.sort_by(|a, b| a.x_min.partial_cmp(&b.x_min).unwrap_or(std::cmp::Ordering::Equal));

        let mut cells: Vec<Vec<String>> = vec![Vec::new(); col_count];

        for b in bs {
            let txt = block_text_norm(b);
            let txt = txt.trim();
            if txt.is_empty() {
                continue;
            }
            let ci = nearest_col(b.x_min, &region.col_x);
            cells[ci].push(txt.to_string());
        }

        let row_cells: Vec<String> = cells
            .into_iter()
            .map(|parts| normalize_ws(&parts.join(" ")))
            .collect();

        if row_cells.iter().all(|c| c.trim().is_empty()) {
            continue;
        }

        table_rows.push(row_cells);
    }

    if table_rows.is_empty() {
        return String::new();
    }

    // 5) header
    let first = &table_rows[0];
    let has_header = looks_like_header_row(first);

    let (header, data_rows) = if has_header {
        (first.clone(), table_rows.into_iter().skip(1).collect::<Vec<_>>())
    } else {
        let mut h = Vec::new();
        for i in 0..col_count {
            h.push(format!("Kolumna {}", i + 1));
        }
        (h, table_rows)
    };

    // 6) emit MD table
    let mut out = String::new();

    out.push('|');
    for c in &header {
        out.push(' ');
        out.push_str(&escape_md_cell(c.trim()));
        out.push(' ');
        out.push('|');
    }
    out.push('\n');

    out.push('|');
    for _ in 0..col_count {
        out.push_str(" --- |");
    }
    out.push('\n');

    for mut r in data_rows {
        if r.len() < col_count {
            r.resize(col_count, String::new());
        } else if r.len() > col_count {
            r.truncate(col_count);
        }

        out.push('|');
        for c in &r {
            out.push(' ');
            out.push_str(&escape_md_cell(c.trim()));
            out.push(' ');
            out.push('|');
        }
        out.push('\n');
    }

    out.push('\n');
    out
}

===

fn render_pages_to_md(pages: Vec<PageBox>) -> String {
    let mut out = String::new();

    let note_indent_px: f32 = 30.0;
    let attach_max_gap_px: f32 = 90.0;

    for (pi, page) in pages.iter().enumerate() {
        let mut blocks = page.blocks.clone();
        blocks.sort_by(|a, b| a.y_min.partial_cmp(&b.y_min).unwrap_or(std::cmp::Ordering::Equal));

        // 1) wykryj regiony tabel
        let table_regions = detect_table_regions(&blocks);

        // 2) wyrenderuj tabele
        for region in &table_regions {
            let tmd = render_table_region_to_md(&blocks, region);
            if !tmd.trim().is_empty() {
                out.push_str(&tmd);
            }
        }

        // 3) odfiltruj bloki tabelaryczne (OVERLAP, nie center_y)
        let mut non_table_blocks: Vec<BlockBox> = Vec::new();
        for b in &blocks {
            let in_table = table_regions.iter().any(|r| !(b.y_max < r.y1 || b.y_min > r.y2));
            if !in_table {
                non_table_blocks.push(b.clone());
            }
        }

        // 4) reszta: tekst + notki na blokach nietabelowych
        if !non_table_blocks.is_empty() {
            non_table_blocks.sort_by(|a, b| {
                a.y_min
                    .partial_cmp(&b.y_min)
                    .unwrap_or(std::cmp::Ordering::Equal)
            });

            let mut xmins: Vec<f32> = non_table_blocks.iter().map(|b| b.x_min).collect();
            xmins.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
            let body_left = xmins.get(xmins.len() / 2).copied().unwrap_or(0.0);

            let (bodies, attachments, loose_notes) =
                attach_notes_to_bodies(&non_table_blocks, body_left, note_indent_px, attach_max_gap_px);

            let mut attached_map: std::collections::BTreeMap<usize, Vec<BlockBox>> =
                std::collections::BTreeMap::new();
            for a in attachments {
                attached_map.entry(a.body_idx).or_default().push(a.note);
            }

            for (bi, body) in bodies.iter().enumerate() {
                if body.lines.is_empty() {
                    continue;
                }

                let mut lines = body.lines.clone();
                lines.sort_by(|a, b| a.y_min.partial_cmp(&b.y_min).unwrap_or(std::cmp::Ordering::Equal));

                let body_txt = render_block_lines_to_md(&lines);
                if !body_txt.trim().is_empty() {
                    out.push_str(body_txt.trim());
                    out.push_str("\n\n");
                }

                if let Some(notes_for_body) = attached_map.get(&bi) {
                    for note in notes_for_body {
                        if note.lines.is_empty() {
                            continue;
                        }
                        let mut nlines = note.lines.clone();
                        nlines.sort_by(|a, b| a.y_min.partial_cmp(&b.y_min).unwrap_or(std::cmp::Ordering::Equal));

                        let note_txt = render_note_block_as_callout(&nlines);
                        if !note_txt.trim().is_empty() {
                            out.push_str(&note_txt);
                        }
                    }
                }
            }

            if !loose_notes.is_empty() {
                out.push('\n');
                for note in loose_notes {
                    if note.lines.is_empty() {
                        continue;
                    }
                    let mut nlines = note.lines.clone();
                    nlines.sort_by(|a, b| a.y_min.partial_cmp(&b.y_min).unwrap_or(std::cmp::Ordering::Equal));

                    let note_txt = render_note_block_as_callout(&nlines);
                    if !note_txt.trim().is_empty() {
                        out.push_str(&note_txt);
                    }
                }
                out.push('\n');
            }
        }

        if pi + 1 < pages.len() {
            out.push_str("\n---\n\n");
        }
    }

    out
}
