use std::collections::{BTreeMap, HashMap};

#[derive(Debug, Clone)]
pub struct TableRegion {
    pub y1: f32,
    pub y2: f32,
    pub col_x: Vec<f32>, // centroidy kolumn (x_min)
}

/// Normalizacja whitespace do porównań i sklejeń
fn normalize_ws(s: &str) -> String {
    s.split_whitespace().collect::<Vec<_>>().join(" ")
}

fn block_text_norm(b: &BlockBox) -> String {
    let mut parts: Vec<String> = b
        .lines
        .iter()
        .map(|l| normalize_ws(&line_to_text(l)))
        .collect();
    parts.retain(|p| !p.is_empty());
    normalize_ws(&parts.join(" "))
}

fn block_center_y(b: &BlockBox) -> f32 {
    (b.y_min + b.y_max) * 0.5
}

fn block_width(b: &BlockBox) -> f32 {
    (b.x_max - b.x_min).max(0.0)
}

/// Proste klastrowanie x_min -> centroidy (tol w px)
fn cluster_xmins(mut xs: Vec<f32>, tol: f32) -> Vec<f32> {
    xs.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
    let mut clusters: Vec<Vec<f32>> = Vec::new();

    for x in xs {
        if let Some(last) = clusters.last_mut() {
            let mean = last.iter().sum::<f32>() / last.len() as f32;
            if (x - mean).abs() <= tol {
                last.push(x);
                continue;
            }
        }
        clusters.push(vec![x]);
    }

    clusters
        .into_iter()
        .map(|c| c.iter().sum::<f32>() / c.len() as f32)
        .collect()
}

fn escape_md_cell(s: &str) -> String {
    // minimalnie: pipes psują tabelę
    s.replace('|', r"\|")
}

fn looks_like_header_row(cells: &[String]) -> bool {
    if cells.is_empty() {
        return false;
    }

    // header zwykle: mało cyfr, raczej krótsze, często uppercase
    let mut non_empty = 0;
    let mut digit_ratio_sum = 0.0f32;
    let mut len_sum = 0usize;
    let mut upperish = 0usize;

    for c in cells {
        let t = c.trim();
        if t.is_empty() {
            continue;
        }
        non_empty += 1;
        len_sum += t.len();

        let digits = t.chars().filter(|ch| ch.is_ascii_digit()).count();
        digit_ratio_sum += digits as f32 / (t.len().max(1) as f32);

        // “upperish”: dużo wielkich liter (nagłówki często tak wyglądają)
        let letters = t.chars().filter(|ch| ch.is_alphabetic()).count();
        let uppers = t.chars().filter(|ch| ch.is_uppercase()).count();
        if letters > 0 && (uppers as f32 / letters as f32) > 0.6 {
            upperish += 1;
        }
    }

    if non_empty == 0 {
        return false;
    }

    let avg_len = len_sum as f32 / non_empty as f32;
    let avg_digit_ratio = digit_ratio_sum / non_empty as f32;

    // dość konserwatywnie:
    avg_len <= 60.0 && avg_digit_ratio < 0.15 && upperish >= 1
}

===

pub fn detect_table_regions(blocks_sorted_by_y: &[BlockBox]) -> Vec<TableRegion> {
    if blocks_sorted_by_y.len() < 6 {
        return Vec::new();
    }

    // ---- strojenie ----
    let band_h: f32 = 20.0;           // grupowanie wierszy
    let x_cluster_tol: f32 = 14.0;    // tolerancja do klastrów kolumn
    let min_region_bands: usize = 3;  // ile bandów, by uznać region tabeli
    let min_cols: usize = 2;
    let max_cell_avg_len: f32 = 140.0; // tabela może mieć długie komórki, ale nie “ciągły artykuł”
    let min_multi_col_band_ratio: f32 = 0.65; // w regionie większość bandów ma >=2 kolumny “w tym samym wierszu”
    let min_shortish_ratio: f32 = 0.55;       // większość komórek raczej krótsza (heurystyka)

    // 1) bandy po center_y
    let mut bands: BTreeMap<i64, Vec<&BlockBox>> = BTreeMap::new();
    for b in blocks_sorted_by_y {
        let key = (block_center_y(b) / band_h).round() as i64;
        bands.entry(key).or_default().push(b);
    }

    #[derive(Clone)]
    struct BandInfo {
        k: i64,
        y1: f32,
        y2: f32,
        col_x: Vec<f32>,
        // ile kolumn realnie ma treść w tym bandzie (przypisanie po nearest centroid)
        filled_cols: usize,
        // średnia długość tekstu “komórki”
        avg_cell_len: f32,
        // ratio komórek krótszych (np. <= 80)
        shortish_ratio: f32,
    }

    // 2) licz cechy bandu
    let mut infos: Vec<BandInfo> = Vec::new();

    for (&k, v) in &bands {
        // zbieramy x_min tylko dla bloków z sensowną treścią
        let mut xs: Vec<f32> = Vec::new();
        let mut texts: Vec<String> = Vec::new();

        let mut y1 = f32::INFINITY;
        let mut y2 = f32::NEG_INFINITY;

        for b in v {
            let t = block_text_norm(b);
            if t.trim().is_empty() {
                continue;
            }
            xs.push(b.x_min);
            texts.push(t);

            y1 = y1.min(b.y_min);
            y2 = y2.max(b.y_max);
        }

        if xs.len() < 2 {
            continue;
        }

        let mut col_x = cluster_xmins(xs, x_cluster_tol);
        col_x.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));

        if col_x.len() < min_cols {
            continue;
        }

        // przypisz każdy block do najbliższej kolumny (po x_min)
        let mut col_counts = vec![0usize; col_x.len()];
        let mut cell_lens: Vec<usize> = Vec::new();

        for b in v {
            let t = block_text_norm(b);
            let t = t.trim();
            if t.is_empty() {
                continue;
            }

            // nearest centroid
            let mut best_i = 0usize;
            let mut best_d = f32::INFINITY;
            for (i, cx) in col_x.iter().enumerate() {
                let d = (b.x_min - *cx).abs();
                if d < best_d {
                    best_d = d;
                    best_i = i;
                }
            }

            col_counts[best_i] += 1;
            cell_lens.push(t.len());
        }

        let filled_cols = col_counts.iter().filter(|c| **c > 0).count();
        if filled_cols < 2 {
            // jeśli w bandzie realnie treść tylko w jednej kolumnie,
            // to wygląda bardziej jak multi-column text, nie tabela
            continue;
        }

        let avg_cell_len = if cell_lens.is_empty() {
            0.0
        } else {
            cell_lens.iter().sum::<usize>() as f32 / cell_lens.len() as f32
        };

        let shortish = cell_lens.iter().filter(|l| **l <= 80).count();
        let shortish_ratio = if cell_lens.is_empty() {
            0.0
        } else {
            shortish as f32 / cell_lens.len() as f32
        };

        infos.push(BandInfo {
            k,
            y1: if y1.is_finite() { y1 } else { (k as f32 - 0.5) * band_h },
            y2: if y2.is_finite() { y2 } else { (k as f32 + 0.5) * band_h },
            col_x,
            filled_cols,
            avg_cell_len,
            shortish_ratio,
        });
    }

    if infos.is_empty() {
        return Vec::new();
    }

    // 3) wybierz bandy “tabelowe” (kandydaci)
    //    – tabela może mieć długie komórki, ale region tabeli powinien mieć sporo “komórkowości”
    let mut is_table_band: HashMap<i64, bool> = HashMap::new();
    for bi in &infos {
        let ok = bi.filled_cols >= 2 && bi.avg_cell_len <= max_cell_avg_len;
        is_table_band.insert(bi.k, ok);
    }

    // 4) złącz kolejne bandy w regiony (na podstawie k)
    infos.sort_by(|a, b| a.k.cmp(&b.k));

    let mut regions_raw: Vec<(i64, i64)> = Vec::new();
    let mut start_k: Option<i64> = None;
    let mut prev_k: i64 = 0;

    for bi in &infos {
        let ok = *is_table_band.get(&bi.k).unwrap_or(&false);
        if ok {
            if start_k.is_none() {
                start_k = Some(bi.k);
                prev_k = bi.k;
            } else if bi.k == prev_k + 1 {
                prev_k = bi.k;
            } else {
                // przerwa
                regions_raw.push((start_k.unwrap(), prev_k));
                start_k = Some(bi.k);
                prev_k = bi.k;
            }
        } else if let Some(sk) = start_k.take() {
            regions_raw.push((sk, prev_k));
        }
    }
    if let Some(sk) = start_k.take() {
        regions_raw.push((sk, prev_k));
    }

    // 5) filtr regionów + wyliczenie template kolumn
    let mut out: Vec<TableRegion> = Vec::new();

    for (sk, ek) in regions_raw {
        let band_count = (ek - sk + 1) as usize;
        if band_count < min_region_bands {
            continue;
        }

        // z infos zbierz bandy regionu
        let region_bands: Vec<&BandInfo> = infos
            .iter()
            .filter(|bi| bi.k >= sk && bi.k <= ek)
            .collect();

        if region_bands.is_empty() {
            continue;
        }

        // ratio bandów, które realnie mają >=2 kolumny z treścią
        let multi_col = region_bands.iter().filter(|bi| bi.filled_cols >= 2).count();
        let multi_col_ratio = multi_col as f32 / region_bands.len() as f32;

        // “shortish” – w tabelach porównawczych zwykle sporo krótszych komórek
        let shortish_ratio_avg =
            region_bands.iter().map(|bi| bi.shortish_ratio).sum::<f32>() / region_bands.len() as f32;

        if multi_col_ratio < min_multi_col_band_ratio {
            continue;
        }
        if shortish_ratio_avg < min_shortish_ratio {
            // konserwatywnie: jeśli region wygląda jak “ciągły artykuł w 2 kolumnach”,
            // shortish_ratio będzie niskie.
            continue;
        }

        // Template kolumn: zbierz wszystkie x_min z regionu i zaklastruj
        let mut xs: Vec<f32> = Vec::new();
        let mut y1 = f32::INFINITY;
        let mut y2 = f32::NEG_INFINITY;

        for b in blocks_sorted_by_y {
            let ky = (block_center_y(b) / band_h).round() as i64;
            if ky < sk || ky > ek {
                continue;
            }
            let t = block_text_norm(b);
            if t.trim().is_empty() {
                continue;
            }
            xs.push(b.x_min);
            y1 = y1.min(b.y_min);
            y2 = y2.max(b.y_max);
        }

        if xs.len() < 4 {
            continue;
        }

        let mut col_x = cluster_xmins(xs, x_cluster_tol);
        col_x.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));

        if col_x.len() < min_cols {
            continue;
        }

        out.push(TableRegion { y1, y2, col_x });
    }

    // scal regiony nachodzące/bliskie (opcjonalnie)
    out.sort_by(|a, b| a.y1.partial_cmp(&b.y1).unwrap_or(std::cmp::Ordering::Equal));
    let merge_gap = 12.0;

    let mut merged: Vec<TableRegion> = Vec::new();
    for r in out {
        if let Some(last) = merged.last_mut() {
            if r.y1 <= last.y2 + merge_gap {
                last.y2 = last.y2.max(r.y2);
                // merge kolumn: weź union przez ponowne klastrowanie centroidów
                let mut xs = last.col_x.clone();
                xs.extend(r.col_x.clone());
                let mut cc = cluster_xmins(xs, 18.0);
                cc.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
                last.col_x = cc;
            } else {
                merged.push(r);
            }
        } else {
            merged.push(r);
        }
    }

    merged
}


==

fn detect_table_ranges(blocks_sorted_by_y: &[BlockBox]) -> Vec<(f32, f32)> {
    detect_table_regions(blocks_sorted_by_y)
        .into_iter()
        .map(|r| (r.y1, r.y2))
        .collect()
}


==

pub fn render_table_region_to_md(
    blocks_sorted_by_y: &[BlockBox],
    region: &TableRegion,
) -> String {
    // ---- strojenie ----
    let band_h: f32 = 20.0;
    let x_assign_tol: f32 = 38.0; // tolerancja przypisania bloku do centroidu kolumny

    // 1) wybierz bloki w regionie
    let mut region_blocks: Vec<&BlockBox> = blocks_sorted_by_y
        .iter()
        .filter(|b| {
            let cy = block_center_y(b);
            cy >= region.y1 && cy <= region.y2
        })
        .collect();

    if region_blocks.is_empty() || region.col_x.is_empty() {
        return String::new();
    }

    // 2) grupuj wiersze po bandzie Y
    let mut rows: BTreeMap<i64, Vec<&BlockBox>> = BTreeMap::new();
    for b in &region_blocks {
        let k = (block_center_y(b) / band_h).round() as i64;
        rows.entry(k).or_default().push(*b);
    }

    // 3) zbuduj “cells” per row: Vec<String> o długości = col_count
    let col_count = region.col_x.len();
    let mut table_rows: Vec<Vec<String>> = Vec::new();

    for (_k, mut bs) in rows {
        // sort w wierszu po x_min
        bs.sort_by(|a, b| a.x_min.partial_cmp(&b.x_min).unwrap_or(std::cmp::Ordering::Equal));

        let mut cells: Vec<Vec<String>> = vec![Vec::new(); col_count];

        for b in bs {
            let txt = block_text_norm(b).trim().to_string();
            if txt.is_empty() {
                continue;
            }

            // przypisz do nearest centroid, ale tylko jeśli blisko
            let mut best_i = None;
            let mut best_d = f32::INFINITY;
            for (i, cx) in region.col_x.iter().enumerate() {
                let d = (b.x_min - *cx).abs();
                if d < best_d {
                    best_d = d;
                    best_i = Some(i);
                }
            }

            if let Some(i) = best_i {
                if best_d <= x_assign_tol {
                    cells[i].push(txt);
                }
            }
        }

        // scal teksty w komórkach
        let row_cells: Vec<String> = cells
            .into_iter()
            .map(|parts| normalize_ws(&parts.join(" ")))
            .collect();

        // pomiń puste “wiersze”
        if row_cells.iter().all(|c| c.trim().is_empty()) {
            continue;
        }

        table_rows.push(row_cells);
    }

    if table_rows.is_empty() {
        return String::new();
    }

    // 4) Nagłówek tabeli
    let mut out = String::new();

    let first = &table_rows[0];
    let has_header = looks_like_header_row(first);

    let (header, data_rows) = if has_header {
        (first.clone(), table_rows.into_iter().skip(1).collect::<Vec<_>>())
    } else {
        // generuj nagłówki techniczne, a pierwszy wiersz zostaje danymi
        let mut h = Vec::new();
        for i in 0..col_count {
            h.push(format!("Kolumna {}", i + 1));
        }
        (h, table_rows)
    };

    // emit header
    out.push('|');
    for c in &header {
        out.push(' ');
        out.push_str(&escape_md_cell(c.trim()));
        out.push(' ');
        out.push('|');
    }
    out.push('\n');

    // separator
    out.push('|');
    for _ in 0..col_count {
        out.push_str(" --- |");
    }
    out.push('\n');

    // rows
    for r in data_rows {
        // normalizuj długości
        let mut rr = r;
        if rr.len() < col_count {
            rr.resize(col_count, String::new());
        }
        out.push('|');
        for c in &rr {
            out.push(' ');
            out.push_str(&escape_md_cell(c.trim()));
            out.push(' ');
            out.push('|');
        }
        out.push('\n');
    }

    out.push('\n');
    out
}


==

wpiecie

// 1) wykryj tabelki
let table_regions = detect_table_regions(&blocks);

// 2) wyrenderuj tabelki i zbierz bloki NIE-tabelowe
let mut non_table_blocks: Vec<BlockBox> = Vec::new();

for b in &blocks {
    let cy = (b.y_min + b.y_max) * 0.5;
    let in_table = table_regions.iter().any(|r| cy >= r.y1 && cy <= r.y2);
    if !in_table {
        non_table_blocks.push(b.clone());
    }
}

// render tabel (w kolejności Y)
for r in &table_regions {
    let tmd = render_table_region_to_md(&blocks, r);
    if !tmd.trim().is_empty() {
        out.push_str(&tmd);
    }
}

// 3) dalej operuj już na non_table_blocks (notki + normalny tekst)
let mut nt = non_table_blocks;
nt.sort_by(|a, b| a.y_min.partial_cmp(&b.y_min).unwrap_or(std::cmp::Ordering::Equal));

// body_left licz na NT, nie na tabelach
let mut xmins: Vec<f32> = nt.iter().map(|b| b.x_min).collect();
xmins.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
let body_left = xmins.get(xmins.len() / 2).copied().unwrap_or(0.0);

let (bodies, attachments, loose_notes) =
    attach_notes_to_bodies(&nt, body_left, note_indent_px, attach_max_gap_px);
