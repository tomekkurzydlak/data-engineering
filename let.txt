fn find_two_col_split(line: &str) -> Option<usize> {
    let s = line.trim_end_matches('\n');
    if s.trim().is_empty() {
        return None;
    }

    // szukamy NAJDŁUŻSZEGO ciągu spacji
    let bytes = s.as_bytes();
    let mut best_len = 0usize;
    let mut best_start = 0usize;

    let mut i = 0usize;
    while i < bytes.len() {
        if bytes[i] == b' ' {
            let start = i;
            while i < bytes.len() && bytes[i] == b' ' {
                i += 1;
            }
            let len = i - start;
            if len > best_len {
                best_len = len;
                best_start = start;
            }
        } else {
            i += 1;
        }
    }

    // warunki bezpieczeństwa (strojenie):
    // - korytarz ma być wyraźny (np. >= 8 spacji)
    // - split nie może być przy samym początku/końcu
    if best_len >= 8 {
        let split_at = best_start + best_len / 2;
        // split musi sensownie dzielić linię
        if split_at >= 12 && split_at + 12 < s.len() {
            return Some(split_at);
        }
    }
    None
}

fn split_two_cols(line: &str, split_at: usize) -> (String, String) {
    let s = line.trim_end_matches('\n');
    if split_at >= s.len() {
        return (normalize_ws(s), String::new());
    }
    let (l, r) = s.split_at(split_at);
    (normalize_ws(l.trim()), normalize_ws(r.trim()))
}

==
fn detect_table_runs(lines: &[String]) -> Vec<TableRun> {
    // strojenie
    let min_run_len = 4usize;       // w tym układzie lepiej 4+
    let max_blank_gap = 1usize;     // 1 pusta linia wewnątrz
    let max_no_split_inside = 2usize; // ile kolejnych linii bez splitu tolerujemy w runie
    let split_tol: isize = 6;       // tolerancja przesunięcia splitu

    let mut runs: Vec<TableRun> = Vec::new();

    let mut cur_start: Option<usize> = None;
    let mut cur_end: usize = 0;
    let mut cur_split: usize = 0;

    let mut blank_gap = 0usize;
    let mut no_split_streak = 0usize;

    for (idx, line) in lines.iter().enumerate() {
        let s = line.as_str();

        if s.trim().is_empty() {
            if cur_start.is_some() && blank_gap < max_blank_gap {
                blank_gap += 1;
                continue;
            } else {
                // domknij run jeśli jest
                if let Some(st) = cur_start {
                    if (cur_end - st + 1) >= min_run_len {
                        runs.push(TableRun { start: st, end: cur_end, split_at: cur_split });
                    }
                }
                cur_start = None;
                blank_gap = 0;
                no_split_streak = 0;
                continue;
            }
        }

        let split = find_two_col_split(s);

        match (cur_start, split) {
            (None, Some(sp)) => {
                // start nowego runu
                cur_start = Some(idx);
                cur_end = idx;
                cur_split = sp;
                blank_gap = 0;
                no_split_streak = 0;
            }
            (Some(_), Some(sp)) => {
                // kontynuacja jeśli split podobny
                if ((sp as isize) - (cur_split as isize)).abs() <= split_tol {
                    cur_end = idx;
                    blank_gap = 0;
                    no_split_streak = 0;
                    // lekko uśrednij split (stabilizacja)
                    cur_split = ((cur_split + sp) / 2).max(1);
                } else {
                    // split “uciekł” -> domknij i zacznij nowy run
                    if let Some(st) = cur_start {
                        if (cur_end - st + 1) >= min_run_len {
                            runs.push(TableRun { start: st, end: cur_end, split_at: cur_split });
                        }
                    }
                    cur_start = Some(idx);
                    cur_end = idx;
                    cur_split = sp;
                    blank_gap = 0;
                    no_split_streak = 0;
                }
            }
            (Some(_), None) => {
                // linia bez splitu: może być zawinięciem w jednej kolumnie
                no_split_streak += 1;
                if no_split_streak <= max_no_split_inside {
                    cur_end = idx;
                    blank_gap = 0;
                } else {
                    // za dużo linii bez splitu -> domknij run
                    if let Some(st) = cur_start {
                        if (cur_end - st + 1) >= min_run_len {
                            runs.push(TableRun { start: st, end: cur_end, split_at: cur_split });
                        }
                    }
                    cur_start = None;
                    blank_gap = 0;
                    no_split_streak = 0;
                }
            }
            (None, None) => {
                // nic
            }
        }
    }

    if let Some(st) = cur_start {
        if (cur_end - st + 1) >= min_run_len {
            runs.push(TableRun { start: st, end: cur_end, split_at: cur_split });
        }
    }

    runs
}

==

fn render_table_run_to_md(lines: &[String], run: &TableRun) -> String {
    let mut rows: Vec<(String, String)> = Vec::new();

    for i in run.start..=run.end {
        let line = lines.get(i).map(|s| s.as_str()).unwrap_or("");
        if line.trim().is_empty() {
            continue;
        }
        let (l, r) = split_two_cols(line, run.split_at);

        // jeśli absolutnie nic nie ma, pomiń
        if l.trim().is_empty() && r.trim().is_empty() {
            continue;
        }

        rows.push((l, r));
    }

    if rows.is_empty() {
        return String::new();
    }

    // Heurystyka headera dla 2 kolumn: pierwsza linia, jeśli obie kolumny wyglądają na tytuły
    let first = &rows[0];
    let looks_header = {
        let a = first.0.trim();
        let b = first.1.trim();
        !a.is_empty() && !b.is_empty()
            && a.len() <= 80 && b.len() <= 80
            && a.chars().any(|c| c.is_alphabetic())
            && b.chars().any(|c| c.is_alphabetic())
            && (a.chars().filter(|c| c.is_uppercase()).count() as f32 / a.chars().filter(|c| c.is_alphabetic()).count().max(1) as f32) > 0.35
    };

    let (header_l, header_r, data_start) = if looks_header {
        (rows[0].0.clone(), rows[0].1.clone(), 1usize)
    } else {
        (String::new(), String::new(), 0usize)
    };

    let mut out = String::new();
    out.push_str("| ");
    out.push_str(&escape_md_cell(header_l.trim()));
    out.push_str(" | ");
    out.push_str(&escape_md_cell(header_r.trim()));
    out.push_str(" |\n");

    out.push_str("| --- | --- |\n");

    for (l, r) in rows.into_iter().skip(data_start) {
        out.push_str("| ");
        out.push_str(&escape_md_cell(l.trim()));
        out.push_str(" | ");
        out.push_str(&escape_md_cell(r.trim()));
        out.push_str(" |\n");
    }

    out.push('\n');
    out
}
