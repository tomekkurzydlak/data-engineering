fn is_note_block(
    block: &BlockBox,
    body_left: f32,
    note_indent_px: f32,
    table_regions: &[TableRegion],
) -> bool {
    // 0) jeśli blok w tabeli -> NIGDY note
    if !table_regions.is_empty() {
        let cy = (block.y_min + block.y_max) * 0.5;
        let in_table = table_regions.iter().any(|r| cy >= r.y1 && cy <= r.y2);
        if in_table {
            return false;
        }
    }

    let indent = block.x_min - body_left;

    // 1) indent musi być wyraźny
    if indent < note_indent_px {
        return false;
    }

    // 2) długość tekstu
    let txt_len: usize = block
        .lines
        .iter()
        .map(|l| line_to_text(l))
        .map(|s| s.trim().len())
        .sum::<usize>();

    // 3) heurystyki notki
    let few_lines = block.lines.len() <= 6;
    let not_too_long = txt_len <= 600;

    few_lines && not_too_long
}


==

fn attach_notes_to_bodies(
    blocks_sorted_by_y: &[BlockBox],
    body_left: f32,
    note_indent_px: f32,
    attach_max_gap_px: f32,
    table_regions: &[TableRegion],
) -> (Vec<BlockBox>, Vec<NoteAttachment>, Vec<BlockBox>) {
    // 1) podział na bodies vs notes (notes wyłącznie poza tabelą)
    let mut bodies: Vec<BlockBox> = Vec::new();
    let mut notes: Vec<BlockBox> = Vec::new();

    for b in blocks_sorted_by_y {
        if is_note_block(b, body_left, note_indent_px, table_regions) {
            notes.push(b.clone());
        } else {
            bodies.push(b.clone());
        }
    }

    // 2) indeksowanie bodies
    let indexed_bodies: Vec<IndexedBlock> = bodies
        .iter()
        .cloned()
        .enumerate()
        .map(|(idx, block)| IndexedBlock { idx, block })
        .collect();

    // 3) przypinanie notek do najbliższego body "powyżej"
    let mut attachments: Vec<NoteAttachment> = Vec::new();
    let mut loose_notes: Vec<BlockBox> = Vec::new();

    for note in notes {
        let mut best: Option<(usize, f32)> = None; // (body_idx, gap)

        for ib in &indexed_bodies {
            if ib.block.y_min <= note.y_min {
                let gap = (note.y_min - ib.block.y_max).max(0.0);
                if gap <= attach_max_gap_px {
                    match best {
                        None => best = Some((ib.idx, gap)),
                        Some((_, best_gap)) => {
                            if gap < best_gap {
                                best = Some((ib.idx, gap));
                            }
                        }
                    }
                }
            }
        }

        if let Some((body_idx, _gap)) = best {
            attachments.push(NoteAttachment { body_idx, note });
        } else {
            loose_notes.push(note);
        }
    }

    // stabilność: jeśli wiele notek do jednego body, sort po y_min
    attachments.sort_by(|a, b| {
        a.body_idx
            .cmp(&b.body_idx)
            .then_with(|| a.note.y_min.partial_cmp(&b.note.y_min).unwrap_or(std::cmp::Ordering::Equal))
    });

    (bodies, attachments, loose_notes)
}


==

fn render_pages_to_md(pages: Vec<PageBox>) -> String {
    let mut out = String::new();

    // UWAGA: zwiększam próg notek minimalnie, żeby “prawa kolumna” nie podpadała łatwo,
    // ale kluczowe jest wykluczenie tabel w is_note_block.
    let note_indent_px: f32 = 38.0;
    let attach_max_gap_px: f32 = 90.0;

    for (pi, page) in pages.iter().enumerate() {
        let mut blocks = page.blocks.clone();
        blocks.sort_by(|a, b| a.y_min.partial_cmp(&b.y_min).unwrap_or(std::cmp::Ordering::Equal));

        let mut table_regions = detect_table_regions(&blocks);
        table_regions.sort_by(|a, b| a.y1.partial_cmp(&b.y1).unwrap_or(std::cmp::Ordering::Equal));

        let table_mask = mark_table_blocks(&blocks, &table_regions);

        let mut render_non_table_segment = |y_from: f32, y_to: f32| -> String {
            let mut seg: Vec<BlockBox> = Vec::new();
            for (i, b) in blocks.iter().enumerate() {
                if table_mask[i] {
                    continue;
                }
                if b.y_max <= y_from {
                    continue;
                }
                if b.y_min >= y_to {
                    continue;
                }
                seg.push(b.clone());
            }
            if seg.is_empty() {
                return String::new();
            }

            seg.sort_by(|a, b| a.y_min.partial_cmp(&b.y_min).unwrap_or(std::cmp::Ordering::Equal));

            // body_left tylko dla segmentu
            let mut xmins: Vec<f32> = seg.iter().map(|b| b.x_min).collect();
            xmins.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
            let body_left = xmins.get(xmins.len() / 2).copied().unwrap_or(0.0);

            // KLUCZ: przekazujemy table_regions -> notki nie zjedzą tabel
            let (bodies, attachments, loose_notes) =
                attach_notes_to_bodies(&seg, body_left, note_indent_px, attach_max_gap_px, &table_regions);

            let mut attached_map: std::collections::BTreeMap<usize, Vec<BlockBox>> =
                std::collections::BTreeMap::new();
            for a in attachments {
                attached_map.entry(a.body_idx).or_default().push(a.note);
            }

            let mut o = String::new();
            for (bi, body) in bodies.iter().enumerate() {
                if body.lines.is_empty() {
                    continue;
                }
                let mut lines = body.lines.clone();
                lines.sort_by(|a, b| a.y_min.partial_cmp(&b.y_min).unwrap_or(std::cmp::Ordering::Equal));
                let body_txt = render_block_lines_to_md(&lines);
                if !body_txt.trim().is_empty() {
                    o.push_str(body_txt.trim());
                    o.push_str("\n\n");
                }

                if let Some(notes_for_body) = attached_map.get(&bi) {
                    for note in notes_for_body {
                        if note.lines.is_empty() {
                            continue;
                        }
                        let mut nlines = note.lines.clone();
                        nlines.sort_by(|a, b| a.y_min.partial_cmp(&b.y_min).unwrap_or(std::cmp::Ordering::Equal));
                        let note_txt = render_note_block_as_callout(&nlines);
                        if !note_txt.trim().is_empty() {
                            o.push_str(&note_txt);
                        }
                    }
                }
            }

            if !loose_notes.is_empty() {
                o.push('\n');
                for note in loose_notes {
                    if note.lines.is_empty() {
                        continue;
                    }
                    let mut nlines = note.lines.clone();
                    nlines.sort_by(|a, b| a.y_min.partial_cmp(&b.y_min).unwrap_or(std::cmp::Ordering::Equal));
                    let note_txt = render_note_block_as_callout(&nlines);
                    if !note_txt.trim().is_empty() {
                        o.push_str(&note_txt);
                    }
                }
                o.push('\n');
            }

            o
        };

        // interleaving
        let mut cursor = f32::NEG_INFINITY;
        for r in &table_regions {
            let seg_md = render_non_table_segment(cursor, r.y1);
            if !seg_md.trim().is_empty() {
                out.push_str(&seg_md);
                if !out.ends_with("\n\n") {
                    out.push_str("\n\n");
                }
            }

            let tmd = render_table_region_to_md(&blocks, r);
            if !tmd.trim().is_empty() {
                out.push_str(&tmd);
                if !out.ends_with("\n\n") {
                    out.push_str("\n\n");
                }
            }

            cursor = r.y2;
        }

        let tail_md = render_non_table_segment(cursor, f32::INFINITY);
        if !tail_md.trim().is_empty() {
            out.push_str(&tail_md);
        }

        if pi + 1 < pages.len() {
            out.push_str("\n---\n\n");
        }
    }

    out
}


==

