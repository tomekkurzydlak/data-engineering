pub fn render_table_region_to_md(blocks_sorted_by_y: &[BlockBox], region: &TableRegion) -> String {
    // strojenie
    let y_row_merge_gap: f32 = 7.0; // ile px tolerancji na łączenie wierszy

    if region.col_x.len() < 2 {
        return String::new();
    }

    // 1) bloki w regionie (overlap Y)
    let mut region_blocks: Vec<&BlockBox> = blocks_sorted_by_y
        .iter()
        .filter(|b| !(b.y_max < region.y1 || b.y_min > region.y2))
        .collect();

    if region_blocks.is_empty() {
        return String::new();
    }

    region_blocks.sort_by(|a, b| {
        a.y_min
            .partial_cmp(&b.y_min)
            .unwrap_or(std::cmp::Ordering::Equal)
            .then_with(|| a.x_min.partial_cmp(&b.x_min).unwrap_or(std::cmp::Ordering::Equal))
    });

    fn nearest_col(x: f32, cols: &[f32]) -> usize {
        let mut best_i = 0usize;
        let mut best_d = f32::INFINITY;
        for (i, cx) in cols.iter().enumerate() {
            let d = (x - *cx).abs();
            if d < best_d {
                best_d = d;
                best_i = i;
            }
        }
        best_i
    }

    // 2) grupuj wiersze po y_min (scalaj bliskie)
    let mut rows: Vec<(f32, Vec<&BlockBox>)> = Vec::new(); // (row_y, blocks)
    for b in region_blocks {
        let row_y = b.y_min;
        if let Some((last_y, last_vec)) = rows.last_mut() {
            if (row_y - *last_y).abs() <= y_row_merge_gap {
                last_vec.push(b);
                continue;
            }
        }
        rows.push((row_y, vec![b]));
    }

    let col_count = region.col_x.len();
    let mut table_rows: Vec<Vec<String>> = Vec::new();

    for (_y, mut bs) in rows {
        bs.sort_by(|a, b| a.x_min.partial_cmp(&b.x_min).unwrap_or(std::cmp::Ordering::Equal));
        let mut cells: Vec<Vec<String>> = vec![Vec::new(); col_count];

        for b in bs {
            let txt = block_text_norm(b);
            let txt = txt.trim();
            if txt.is_empty() {
                continue;
            }
            let ci = nearest_col(b.x_min, &region.col_x);
            cells[ci].push(txt.to_string());
        }

        let row_cells: Vec<String> = cells
            .into_iter()
            .map(|parts| normalize_ws(&parts.join(" ")))
            .collect();

        if row_cells.iter().all(|c| c.trim().is_empty()) {
            continue;
        }
        table_rows.push(row_cells);
    }

    if table_rows.is_empty() {
        return String::new();
    }

    // 3) header: tylko jeśli wygląda jak header; w przeciwnym razie pusty header
    let has_header = looks_like_header_row(&table_rows[0]);
    let (header, data_rows) = if has_header {
        (table_rows[0].clone(), table_rows.into_iter().skip(1).collect::<Vec<_>>())
    } else {
        (vec![String::new(); col_count], table_rows)
    };

    // 4) emit markdown table
    let mut out = String::new();

    out.push('|');
    for c in &header {
        out.push(' ');
        out.push_str(&escape_md_cell(c.trim()));
        out.push(' ');
        out.push('|');
    }
    out.push('\n');

    out.push('|');
    for _ in 0..col_count {
        out.push_str(" --- |");
    }
    out.push('\n');

    for mut r in data_rows {
        if r.len() < col_count {
            r.resize(col_count, String::new());
        } else if r.len() > col_count {
            r.truncate(col_count);
        }

        out.push('|');
        for c in &r {
            out.push(' ');
            out.push_str(&escape_md_cell(c.trim()));
            out.push(' ');
            out.push('|');
        }
        out.push('\n');
    }

    out.push('\n');
    out
}
===
pub fn render_non_table_with_notes(
    mut blocks: Vec<BlockBox>,
    note_indent_px: f32,
    attach_max_gap_px: f32,
) -> String {
    if blocks.is_empty() {
        return String::new();
    }

    blocks.sort_by(|a, b| a.y_min.partial_cmp(&b.y_min).unwrap_or(std::cmp::Ordering::Equal));

    // body_left liczony na tym segmencie
    let mut xmins: Vec<f32> = blocks.iter().map(|b| b.x_min).collect();
    xmins.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
    let body_left = xmins.get(xmins.len() / 2).copied().unwrap_or(0.0);

    let (bodies, attachments, loose_notes) =
        attach_notes_to_bodies(&blocks, body_left, note_indent_px, attach_max_gap_px);

    let mut attached_map: std::collections::BTreeMap<usize, Vec<BlockBox>> = std::collections::BTreeMap::new();
    for a in attachments {
        attached_map.entry(a.body_idx).or_default().push(a.note);
    }

    let mut out = String::new();

    for (bi, body) in bodies.iter().enumerate() {
        if body.lines.is_empty() {
            continue;
        }

        let mut lines = body.lines.clone();
        lines.sort_by(|a, b| a.y_min.partial_cmp(&b.y_min).unwrap_or(std::cmp::Ordering::Equal));

        let body_txt = render_block_lines_to_md(&lines);
        if !body_txt.trim().is_empty() {
            out.push_str(body_txt.trim());
            out.push_str("\n\n");
        }

        if let Some(notes_for_body) = attached_map.get(&bi) {
            for note in notes_for_body {
                if note.lines.is_empty() {
                    continue;
                }
                let mut nlines = note.lines.clone();
                nlines.sort_by(|a, b| a.y_min.partial_cmp(&b.y_min).unwrap_or(std::cmp::Ordering::Equal));

                let note_txt = render_note_block_as_callout(&nlines);
                if !note_txt.trim().is_empty() {
                    out.push_str(&note_txt);
                }
            }
        }
    }

    if !loose_notes.is_empty() {
        out.push('\n');
        for note in loose_notes {
            if note.lines.is_empty() {
                continue;
            }
            let mut nlines = note.lines.clone();
            nlines.sort_by(|a, b| a.y_min.partial_cmp(&b.y_min).unwrap_or(std::cmp::Ordering::Equal));

            let note_txt = render_note_block_as_callout(&nlines);
            if !note_txt.trim().is_empty() {
                out.push_str(&note_txt);
            }
        }
        out.push('\n');
    }

    out
}

===
fn render_pages_to_md(pages: Vec<PageBox>) -> String {
    let mut out = String::new();

    let note_indent_px: f32 = 30.0;
    let attach_max_gap_px: f32 = 90.0;

    for (pi, page) in pages.iter().enumerate() {
        let mut blocks = page.blocks.clone();
        blocks.sort_by(|a, b| a.y_min.partial_cmp(&b.y_min).unwrap_or(std::cmp::Ordering::Equal));

        // 1) wykryj tabelki (regiony) i przygotuj maskę bloków tabelowych
        let mut table_regions = detect_table_regions(&blocks);
        table_regions.sort_by(|a, b| a.y1.partial_cmp(&b.y1).unwrap_or(std::cmp::Ordering::Equal));

        let table_mask = mark_table_blocks(&blocks, &table_regions);

        // 2) renderuj w porządku Y: segment tekstu przed tabelą -> tabela -> segment -> tabela...
        let mut cursor_y = f32::NEG_INFINITY;

        for r in &table_regions {
            // 2a) bloki nietabelowe przed regionem tabeli
            let mut seg: Vec<BlockBox> = Vec::new();
            for (i, b) in blocks.iter().enumerate() {
                if table_mask[i] {
                    continue;
                }
                if b.y_max <= cursor_y {
                    continue;
                }
                if b.y_min < r.y1 {
                    seg.push(b.clone());
                }
            }

            let seg_md = render_non_table_with_notes(seg, note_indent_px, attach_max_gap_px);
            if !seg_md.trim().is_empty() {
                out.push_str(&seg_md);
                if !out.ends_with("\n\n") {
                    out.push_str("\n\n");
                }
            }

            // 2b) tabela w miejscu wystąpienia
            let tmd = render_table_region_to_md(&blocks, r);
            if !tmd.trim().is_empty() {
                out.push_str(&tmd);
                if !out.ends_with("\n\n") {
                    out.push_str("\n\n");
                }
            }

            cursor_y = r.y2;
        }

        // 3) ogon: bloki nietabelowe po ostatniej tabeli
        let mut tail: Vec<BlockBox> = Vec::new();
        for (i, b) in blocks.iter().enumerate() {
            if table_mask[i] {
                continue;
            }
            if b.y_max <= cursor_y {
                continue;
            }
            tail.push(b.clone());
        }

        let tail_md = render_non_table_with_notes(tail, note_indent_px, attach_max_gap_px);
        if !tail_md.trim().is_empty() {
            out.push_str(&tail_md);
        }

        if pi + 1 < pages.len() {
            out.push_str("\n---\n\n");
        }
    }

    out
}
