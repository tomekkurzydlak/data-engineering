fn is_note_block(
    block: &BlockBox,
    body_left: f32,
    note_indent_px: f32,
    table_ranges: &[(f32, f32)],
) -> bool {
    let indent = block.x_min - body_left;

    // 1) jeśli w tabeli -> NIGDY note
    if is_block_in_table_range(block, table_ranges) {
        return false;
    }

    // 2) indent musi być wyraźny
    if indent < note_indent_px {
        return false;
    }

    // 3) dodatkowy bezpiecznik: notki zwykle są "krótkie" i nie mają wielu linii
    // (w razie potrzeby poluzuj)
    let txt_len = block_text(block).len();
    let few_lines = block.lines.len() <= 6;
    let not_too_long = txt_len <= 600;

    few_lines && not_too_long
}

fn attach_notes_to_bodies(
    blocks_sorted_by_y: &[BlockBox],
    body_left: f32,
    note_indent_px: f32,
    attach_max_gap_px: f32,
) -> (Vec<BlockBox>, Vec<NoteAttachment>, Vec<BlockBox>) {
    // 0) wykryj obszary tabel na stronie (zakresy Y)
    let table_ranges = detect_table_ranges(blocks_sorted_by_y);

    // 1) podział na bodies vs notes (notes wyłącznie poza tabelą)
    let mut bodies: Vec<BlockBox> = Vec::new();
    let mut notes: Vec<BlockBox> = Vec::new();

    for b in blocks_sorted_by_y {
        if is_note_block(b, body_left, note_indent_px, &table_ranges) {
            notes.push(b.clone());
        } else {
            bodies.push(b.clone());
        }
    }

    // 2) indeksowanie bodies
    let indexed_bodies: Vec<IndexedBlock> = bodies
        .iter()
        .cloned()
        .enumerate()
        .map(|(idx, block)| IndexedBlock { idx, block })
        .collect();

    // 3) przypinanie notek do najbliższego body "powyżej"
    let mut attachments: Vec<NoteAttachment> = Vec::new();
    let mut loose_notes: Vec<BlockBox> = Vec::new();

    for note in notes {
        let mut best: Option<(usize, f32)> = None; // (body_idx, gap)

        for ib in &indexed_bodies {
            if ib.block.y_min <= note.y_min {
                let gap = (note.y_min - ib.block.y_max).max(0.0);
                if gap <= attach_max_gap_px {
                    match best {
                        None => best = Some((ib.idx, gap)),
                        Some((_, best_gap)) => {
                            if gap < best_gap {
                                best = Some((ib.idx, gap));
                            }
                        }
                    }
                }
            }
        }

        if let Some((body_idx, _gap)) = best {
            attachments.push(NoteAttachment { body_idx, note });
        } else {
            loose_notes.push(note);
        }
    }

    // stabilność: jeśli wiele notek do jednego body, sort po y_min
    attachments.sort_by(|a, b| {
        a.body_idx
            .cmp(&b.body_idx)
            .then_with(|| a.note.y_min.partial_cmp(&b.note.y_min).unwrap_or(std::cmp::Ordering::Equal))
    });

    (bodies, attachments, loose_notes)
}


====

fn is_block_in_table_range(block: &BlockBox, table_ranges: &[(f32, f32)]) -> bool {
    if table_ranges.is_empty() {
        return false;
    }
    let cy = (block.y_min + block.y_max) * 0.5;
    table_ranges.iter().any(|(y1, y2)| cy >= *y1 && cy <= *y2)
}

/// Heurystyka tabeli:
/// - szukamy zakresów Y, gdzie są >= 2 kolumny (xMin klastruje się w 2+ grupy)
/// - i jest "gęsto" w pionie (wiele bloków w podobnym y-band)
fn detect_table_ranges(blocks_sorted_by_y: &[BlockBox]) -> Vec<(f32, f32)> {
    if blocks_sorted_by_y.len() < 8 {
        return Vec::new();
    }

    // --- parametry strojenia ---
    let col_split_min_gap: f32 = 80.0;  // minimalna przerwa X by uznać, że to inna kolumna
    let band_h: f32 = 18.0;             // rozmiar banda Y (grupowanie wierszy)
    let min_blocks_in_band: usize = 4;  // ile bloków w jednym bandzie, żeby podejrzewać tabelę
    let min_bands: usize = 3;           // ile bandów, żeby uznać zakres za tabelę

    // 1) grupuj bloki po bandach Y
    use std::collections::BTreeMap;
    let mut bands: BTreeMap<i64, Vec<&BlockBox>> = BTreeMap::new();

    for b in blocks_sorted_by_y {
        let key = (b.y_min / band_h).round() as i64;
        bands.entry(key).or_default().push(b);
    }

    // 2) oceń, czy band wygląda jak wiersz tabeli (2+ kolumny)
    let mut good_band_keys: Vec<i64> = Vec::new();

    for (k, v) in &bands {
        if v.len() < min_blocks_in_band {
            continue;
        }

        // xMin posortowane
        let mut xs: Vec<f32> = v.iter().map(|b| b.x_min).collect();
        xs.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));

        // policz "pęknięcia" między klastrami
        let mut clusters = 1usize;
        for i in 1..xs.len() {
            if (xs[i] - xs[i - 1]) >= col_split_min_gap {
                clusters += 1;
            }
        }

        if clusters >= 2 {
            good_band_keys.push(*k);
        }
    }

    if good_band_keys.len() < min_bands {
        return Vec::new();
    }

    // 3) złącz sąsiednie bandy w zakresy
    good_band_keys.sort();
    let mut ranges: Vec<(f32, f32)> = Vec::new();

    let mut start_k = good_band_keys[0];
    let mut prev_k = good_band_keys[0];

    for &k in good_band_keys.iter().skip(1) {
        if k == prev_k + 1 {
            prev_k = k;
        } else {
            let y1 = (start_k as f32 - 0.5) * band_h;
            let y2 = (prev_k as f32 + 0.5) * band_h;
            ranges.push((y1, y2));
            start_k = k;
            prev_k = k;
        }
    }
    let y1 = (start_k as f32 - 0.5) * band_h;
    let y2 = (prev_k as f32 + 0.5) * band_h;
    ranges.push((y1, y2));

    // 4) scal bliskie zakresy (opcjonalnie)
    let merge_gap: f32 = 25.0;
    ranges.sort_by(|a, b| a.0.partial_cmp(&b.0).unwrap_or(std::cmp::Ordering::Equal));
    let mut merged: Vec<(f32, f32)> = Vec::new();

    for (a, b) in ranges {
        if let Some(last) = merged.last_mut() {
            if a <= last.1 + merge_gap {
                last.1 = last.1.max(b);
            } else {
                merged.push((a, b));
            }
        } else {
            merged.push((a, b));
        }
    }

    merged
}


===


fn render_block_lines_to_md(lines: &[LineBox]) -> String {
    if lines.is_empty() {
        return String::new();
    }

    // --- progi (stroić na realnych PDF-ach) ---
    let paragraph_gap: f32 = 10.0;

    // listy
    let indent_step_px: f32 = 22.0;
    let continuation_gap_px: f32 = 10.0;
    let continuation_indent_px: f32 = 28.0; // było 18, zwiększamy tolerancję
    let orphan_merge_gap_px: f32 = 12.0;    // max gap pionowy do sklejenia markera z treścią

    // --- body_left: lokalnie dla bloku ---
    let mut body_left = f32::INFINITY;
    for l in lines {
        let t = line_to_text(l);
        if t.len() >= 20 {
            body_left = body_left.min(l.x_min);
        }
    }
    if !body_left.is_finite() {
        body_left = lines.first().map(|l| l.x_min).unwrap_or(0.0);
    }

    // --- body_width: mediana szerokości "typowych" linii ---
    let mut widths: Vec<f32> = lines
        .iter()
        .map(|l| (l.x_max - body_left).max(0.0))
        .collect();
    widths.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
    let body_width = widths.get(widths.len() / 2).copied().unwrap_or(500.0);

    // 0) pre-pass: sklej "osierocone" markery listy z następną linią
    let merged_lines = merge_orphan_list_markers(lines, orphan_merge_gap_px);

    let mut out = String::new();

    // --- state list ---
    let mut in_list: bool = false;
    let mut list_base_content_x: f32 = 0.0;
    let mut last_item_content_x: f32 = 0.0;
    let mut last_level: usize = 0;

    for i in 0..merged_lines.len() {
        let line = &merged_lines[i];
        let text = line_to_text(line);

        if text.is_empty() {
            continue;
        }

        let prev_gap = if i == 0 {
            999.0
        } else {
            (line.y_min - merged_lines[i - 1].y_max).abs()
        };

        let next_gap = if i + 1 >= merged_lines.len() {
            999.0
        } else {
            (merged_lines[i + 1].y_min - line.y_max).abs()
        };

        // Block break = nowy akapit
        if line.block_break_before {
            if in_list {
                out.push_str("\n\n");
                in_list = false;
            } else if !out.is_empty() && !out.ends_with("\n\n") {
                out.push_str("\n\n");
            }
        }

        // --- blokada headingów dla "gołych" numerków/bulletów ---
        // To eliminuje przypadki typu: "##1" albo samotne "1"
        if is_standalone_listish_line(line) {
            // potraktuj to jak zwykłą linię (bez headingów)
        } else {
            // --- heurystyka nagłówka ---
            let line_w = (line.x_max - line.x_min).max(0.0);
            let short_line = line_w < body_width * 0.75;
            let separated = prev_gap >= 12.0 && next_gap >= 12.0;
            let not_body_start = (line.x_min - body_left).abs() > 4.0;

            // dodatkowy warunek: nie rób headingów z bardzo krótkich "liczb"
            let looks_numeric_only = text.trim().len() <= 3 && text.trim().chars().all(|c| c.is_ascii_digit());
            let looks_like_heading = !looks_numeric_only && text.len() <= 120 && short_line && (separated || not_body_start);

            if looks_like_heading {
                if in_list {
                    out.push_str("\n\n");
                    in_list = false;
                } else if !out.is_empty() && !out.ends_with("\n\n") {
                    out.push_str("\n\n");
                }

                let level = if line_w < body_width * 0.45 { "##" } else { "###" };
                out.push_str(level);
                out.push(' ');
                out.push_str(text.trim());
                out.push_str("\n\n");
                continue;
            }
        }

        // --- LIST ITEM START ---
        if let Some(marker) = parse_list_marker(line) {
            let item_content_x = content_x_min_after_marker(line, marker.consume_words);

            if !in_list {
                if !out.is_empty() && !out.ends_with("\n\n") {
                    out.push_str("\n\n");
                }
                in_list = true;
                list_base_content_x = item_content_x;
                last_level = 0;
            }

            let raw = ((item_content_x - list_base_content_x) / indent_step_px).round();
            let level = raw.max(0.0) as usize;

            last_level = level;
            last_item_content_x = item_content_x;

            for _ in 0..level {
                out.push_str("  ");
            }

            match marker.kind {
                ListKind::Ordered => out.push_str("1. "),
                ListKind::Unordered => out.push_str("- "),
            }

            let item_text = line
                .words
                .iter()
                .skip(marker.consume_words)
                .map(|w| w.text.as_str())
                .collect::<Vec<_>>()
                .join(" ");

            out.push_str(item_text.trim());
            continue;
        }

        // --- LIST CONTINUATION ---
        if in_list {
            let is_close_vertically = prev_gap < continuation_gap_px;

            let content_x = line
                .words
                .first()
                .map(|w| w.x_min)
                .unwrap_or(line.x_min);

            let likely_continuation = is_close_vertically
                && content_x >= last_item_content_x - 4.0
                && content_x <= last_item_content_x + continuation_indent_px;

            if likely_continuation {
                out.push('\n');
                for _ in 0..last_level {
                    out.push_str("  ");
                }
                out.push_str("   ");
                out.push_str(text.trim());
                continue;
            }

            out.push_str("\n\n");
            in_list = false;
        }

        // --- zwykłe akapity ---
        if out.is_empty() {
            out.push_str(text.trim());
        } else if prev_gap >= paragraph_gap {
            if !out.ends_with("\n\n") {
                out.push_str("\n\n");
            }
            out.push_str(text.trim());
        } else {
            out.push('\n');
            out.push_str(text.trim());
        }
    }

    out.trim_end().to_string()
}



===


fn is_standalone_listish_line(line: &LineBox) -> bool {
    // linia która wygląda jak sam marker (np. "1)" albo "-")
    if let Some(m) = parse_list_marker(line) {
        // jeśli marker zjada wszystkie słowa -> to jest goły marker
        return line.words.len() <= m.consume_words;
    }
    false
}

fn merge_orphan_list_markers(lines: &[LineBox], orphan_merge_gap_px: f32) -> Vec<LineBox> {
    let mut out: Vec<LineBox> = Vec::new();
    let mut i = 0;

    while i < lines.len() {
        let cur = &lines[i];

        // jeśli to "goły marker" i mamy następną linię, spróbuj skleić
        if is_standalone_listish_line(cur) && i + 1 < lines.len() {
            let next = &lines[i + 1];
            let gap = (next.y_min - cur.y_max).abs();

            // warunek pionowy + next ma treść
            if gap <= orphan_merge_gap_px && !line_to_text(next).trim().is_empty() {
                // sklej: words = marker.words + next.words
                let mut merged_words = cur.words.clone();
                merged_words.extend(next.words.clone());

                // nowa linia: geometria obejmuje oba
                let merged = LineBox {
                    y_min: cur.y_min.min(next.y_min),
                    y_max: cur.y_max.max(next.y_max),
                    x_min: cur.x_min.min(next.x_min),
                    x_max: cur.x_max.max(next.x_max),
                    words: merged_words,
                    // block_break: jeśli marker miał block break, zachowaj
                    block_break_before: cur.block_break_before,
                };

                out.push(merged);
                i += 2;
                continue;
            }
        }

        out.push(cur.clone());
        i += 1;
    }

    out
}


==

fn parse_list_marker(line: &LineBox) -> Option<ListMarker> {
    let w0 = line.words.get(0)?.text.trim();
    if w0.is_empty() {
        return None;
    }

    // Unordered bullets
    if matches!(w0, "-" | "•" | "*" | "·" | "o" | "–" | "—") {
        return Some(ListMarker { kind: ListKind::Unordered, consume_words: 1 });
    }

    // 1) przypadek: "1." / "1)" / "10." / "10)" jako 1 word
    if looks_like_ordered_token_1word(w0) {
        return Some(ListMarker { kind: ListKind::Ordered, consume_words: 1 });
    }

    // 2) przypadek: PDF rozbija "1)" na ["1", ")"] albo "1." na ["1", "."]
    let w1 = line.words.get(1).map(|w| w.text.trim()).unwrap_or("");
    if !w1.is_empty() && looks_like_ordered_token_2words(w0, w1) {
        return Some(ListMarker { kind: ListKind::Ordered, consume_words: 2 });
    }

    // 3) przypadek: "(1)" bywa rozbite na "(", "1", ")" -> 3 słowa
    let w2 = line.words.get(2).map(|w| w.text.trim()).unwrap_or("");
    if !w2.is_empty() && looks_like_ordered_token_3words(w0, w1, w2) {
        return Some(ListMarker { kind: ListKind::Ordered, consume_words: 3 });
    }

    None
}

fn looks_like_ordered_token_1word(s: &str) -> bool {
    let s = s.trim();

    // dopuszczamy nawiasy: "(1)" albo "(1)"
    let s = s.trim_start_matches('(').trim_end_matches(')');

    // [0-9]+[.)]
    let bytes = s.as_bytes();
    if bytes.is_empty() {
        return false;
    }

    let mut i = 0;
    while i < bytes.len() && bytes[i].is_ascii_digit() {
        i += 1;
    }
    if i == 0 || i >= bytes.len() {
        return false;
    }

    matches!(bytes[i] as char, '.' | ')')
}

fn looks_like_ordered_token_2words(w0: &str, w1: &str) -> bool {
    let n = w0.trim();
    let p = w1.trim();
    if n.is_empty() || p.is_empty() {
        return false;
    }
    if !n.chars().all(|c| c.is_ascii_digit()) {
        return false;
    }
    matches!(p, "." | ")" )
}

fn looks_like_ordered_token_3words(w0: &str, w1: &str, w2: &str) -> bool {
    let a = w0.trim();
    let b = w1.trim();
    let c = w2.trim();
    if a != "(" || c != ")" {
        return false;
    }
    b.chars().all(|ch| ch.is_ascii_digit())
}


==



