pub async fn run_independent_standardized(&self, files: Vec<FileProcess>) -> Result<()> {
        let (tx, rx) = unbounded();
        let busy = Arc::new(AtomicUsize::new(0));

        // uruchamiamy workerów
        for _ in 0..MAX_WORKERS {
            self.spawn_worker_standardized(rx.clone(), busy.clone());
        }

        // wysyłamy zadania: każdy plik → każdy krok
        for f in &files {
            for step in &f.processes {
                tx.send((f.file_id.clone(), f.gcs_file_uri.clone(), step.clone()))
                    .unwrap();
            }
        }

        drop(tx);

        // czekamy aż wszystkie zadania się wykonają
        while busy.load(Ordering::SeqCst) > 0 {
            tokio::time::sleep(Duration::from_millis(200)).await;
        }
        Ok(())
    }

    fn spawn_worker_standardized(
        &self,
        rx: Receiver<(String, String, ProcessStep)>,
        busy: Arc<AtomicUsize>,
    ) {
        let backend = Arc::clone(&self.backend);
        let handle = Handle::current();

        thread::spawn(move || {
            while let Ok((file_id, gcs, step)) = rx.recv() {
                busy.fetch_add(1, Ordering::SeqCst);

                handle.block_on(async {
                    let payload = json!({
                        "file_id": file_id,
                        "gcs_file_uri": gcs,
                        "seq": step.exec_process_seq,
                    });

                    match backend.start_job(&step.exec_object_nm, &payload).await {
                        Ok(exec_id) => {
                            println!("STD-INDEP file={} seq={} exec={}", file_id, step.exec_process_seq, exec_id);
                            let _ = backend.poll_until_done(&exec_id, Duration::from_secs(600), Duration::from_secs(5)).await;
                        }
                        Err(err) => {
                            eprintln!("ERR: start_job {}: {}", file_id, err);
                        }
                    }
                });

                busy.fetch_sub(1, Ordering::SeqCst);
            }
        });
    }


    =====

    pub async fn run(&self, files: Vec<FileProcess>) -> Result<()> {
        // start procesu
        if let Some(db) = &self.db {
            db.start_process().await?;
        }

        if self.cfg.standardized_mode {
            if self.cfg.independent_steps {
                // STANDARDIZED + INDEPENDENT
                self.run_independent_standardized(files.clone()).await?;
            } else {
                // STANDARDIZED + SYNCHRONIZED
                self.run_synchronized(&files).await?;
            }
        } else {
            // DYNAMIC MODE (zawsze independent)
            self.run_independent_dynamic(files.clone()).await?;
        }

        // finish procesu
        if let Some(db) = &self.db {
            db.finish_process().await?;
        }

        Ok(())
    }
