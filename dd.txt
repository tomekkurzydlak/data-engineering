fn parse_bbox_layout_pages(xhtml: &str) -> Result<Vec<PageBox>> {
    let mut reader = Reader::from_str(xhtml);
    reader.config_mut().trim_text(true);

    let mut buf = Vec::new();

    // --- state: page ---
    let mut pages: Vec<PageBox> = Vec::new();
    let mut cur_page_no: usize = 0;
    let mut cur_page_w: f32 = 0.0;
    let mut cur_page_h: f32 = 0.0;
    let mut cur_page_blocks: Vec<BlockBox> = Vec::new();
    let mut in_page = false;

    // --- state: block ---
    let mut in_block = false;
    let mut b_xmin: Option<f32> = None;
    let mut b_ymin: Option<f32> = None;
    let mut b_xmax: Option<f32> = None;
    let mut b_ymax: Option<f32> = None;
    let mut block_lines: Vec<LineBox> = Vec::new();

    // --- state: line ---
    let mut in_line = false;
    let mut line_words: Vec<WordBox> = Vec::new();
    let mut line_ymin: Option<f32> = None;
    let mut line_ymax: Option<f32> = None;
    let mut line_xmin: Option<f32> = None;
    let mut line_xmax: Option<f32> = None;

    // --- state: word ---
    let mut in_word = false;
    let mut w_xmin: Option<f32> = None;
    let mut w_ymin: Option<f32> = None;
    let mut w_xmax: Option<f32> = None;
    let mut w_ymax: Option<f32> = None;
    let mut word_text = String::new();

    loop {
        match reader.read_event_into(&mut buf) {
            Ok(Event::Start(e)) => match e.name().as_ref() {
                b"page" => {
                    in_page = true;
                    cur_page_no += 1;
                    cur_page_blocks.clear();

                    cur_page_w = 0.0;
                    cur_page_h = 0.0;

                    for a in e.attributes().with_checks(false) {
                        let a = a.map_err(|e| anyhow!(e.to_string()))?;
                        let key = a.key.as_ref();
                        let val = a.unescape_value().map_err(|e| anyhow!(e.to_string()))?;
                        let v = val.as_ref();

                        match key {
                            b"width" => cur_page_w = parse_f32_attr(v).unwrap_or(0.0),
                            b"height" => cur_page_h = parse_f32_attr(v).unwrap_or(0.0),
                            _ => {}
                        }
                    }
                }

                b"block" => {
                    in_block = true;
                    block_lines.clear();

                    b_xmin = None;
                    b_ymin = None;
                    b_xmax = None;
                    b_ymax = None;

                    for a in e.attributes().with_checks(false) {
                        let a = a.map_err(|e| anyhow!(e.to_string()))?;
                        let key = a.key.as_ref();
                        let val = a.unescape_value().map_err(|e| anyhow!(e.to_string()))?;
                        let v = val.as_ref();

                        match key {
                            b"xMin" => b_xmin = parse_f32_attr(v),
                            b"yMin" => b_ymin = parse_f32_attr(v),
                            b"xMax" => b_xmax = parse_f32_attr(v),
                            b"yMax" => b_ymax = parse_f32_attr(v),
                            _ => {}
                        }
                    }
                }

                b"line" => {
                    in_line = true;
                    line_words.clear();
                    line_ymin = None;
                    line_ymax = None;
                    line_xmin = None;
                    line_xmax = None;

                    for a in e.attributes().with_checks(false) {
                        let a = a.map_err(|e| anyhow!(e.to_string()))?;
                        let key = a.key.as_ref();
                        let val = a.unescape_value().map_err(|e| anyhow!(e.to_string()))?;
                        let v = val.as_ref();

                        match key {
                            b"xMin" => line_xmin = parse_f32_attr(v),
                            b"yMin" => line_ymin = parse_f32_attr(v),
                            b"xMax" => line_xmax = parse_f32_attr(v),
                            b"yMax" => line_ymax = parse_f32_attr(v),
                            _ => {}
                        }
                    }
                }

                b"word" => {
                    in_word = true;
                    word_text.clear();

                    w_xmin = None;
                    w_ymin = None;
                    w_xmax = None;
                    w_ymax = None;

                    for a in e.attributes().with_checks(false) {
                        let a = a.map_err(|e| anyhow!(e.to_string()))?;
                        let key = a.key.as_ref();
                        let val = a.unescape_value().map_err(|e| anyhow!(e.to_string()))?;
                        let v = val.as_ref();

                        match key {
                            b"xMin" => w_xmin = parse_f32_attr(v),
                            b"yMin" => w_ymin = parse_f32_attr(v),
                            b"xMax" => w_xmax = parse_f32_attr(v),
                            b"yMax" => w_ymax = parse_f32_attr(v),
                            _ => {}
                        }
                    }
                }

                _ => {}
            },

            Ok(Event::Text(t)) => {
                if in_word {
                    let s = reader
                        .decoder()
                        .decode(t.as_ref())
                        .map_err(|e| anyhow!(e.to_string()))?;
                    let s = s.trim();
                    if !s.is_empty() {
                        word_text.push_str(s);
                    }
                }
            }

            Ok(Event::End(e)) => match e.name().as_ref() {
                b"word" => {
                    in_word = false;
                    let text = word_text.trim().to_string();

                    if !text.is_empty() {
                        if let (Some(x1), Some(y1), Some(x2), Some(y2)) = (w_xmin, w_ymin, w_xmax, w_ymax) {
                            line_words.push(WordBox { x_min: x1, y_min: y1, x_max: x2, y_max: y2, text });
                        }
                    }
                    word_text.clear();
                }

                b"line" => {
                    in_line = false;

                    if !line_words.is_empty() {
                        line_words.sort_by(|a, b| a.x_min.partial_cmp(&b.x_min).unwrap_or(std::cmp::Ordering::Equal));

                        let x_min = line_xmin.unwrap_or_else(|| line_words.first().map(|w| w.x_min).unwrap_or(0.0));
                        let x_max = line_xmax.unwrap_or_else(|| line_words.last().map(|w| w.x_max).unwrap_or(0.0));

                        let y_min = line_ymin.unwrap_or_else(|| line_words.iter().map(|w| w.y_min).fold(f32::INFINITY, f32::min));
                        let y_max = line_ymax.unwrap_or_else(|| line_words.iter().map(|w| w.y_max).fold(f32::NEG_INFINITY, f32::max));

                        block_lines.push(LineBox { y_min, y_max, x_min, x_max, words: line_words.clone() });
                    }
                }

                b"block" => {
                    in_block = false;

                    if !block_lines.is_empty() {
                        // sort linii w bloku po Y
                        block_lines.sort_by(|a, b| a.y_min.partial_cmp(&b.y_min).unwrap_or(std::cmp::Ordering::Equal));

                        let x_min = b_xmin.unwrap_or_else(|| block_lines.iter().map(|l| l.x_min).fold(f32::INFINITY, f32::min));
                        let x_max = b_xmax.unwrap_or_else(|| block_lines.iter().map(|l| l.x_max).fold(f32::NEG_INFINITY, f32::max));
                        let y_min = b_ymin.unwrap_or_else(|| block_lines.iter().map(|l| l.y_min).fold(f32::INFINITY, f32::min));
                        let y_max = b_ymax.unwrap_or_else(|| block_lines.iter().map(|l| l.y_max).fold(f32::NEG_INFINITY, f32::max));

                        cur_page_blocks.push(BlockBox { x_min, y_min, x_max, y_max, lines: block_lines.clone() });
                    }
                }

                b"page" => {
                    in_page = false;
                    pages.push(PageBox {
                        page_no: cur_page_no,
                        width: cur_page_w,
                        height: cur_page_h,
                        blocks: cur_page_blocks.clone(),
                    });
                }

                _ => {}
            },

            Ok(Event::Eof) => break,
            Err(e) => return Err(anyhow!(e.to_string())),
            _ => {}
        }

        buf.clear();
    }

    Ok(pages)
}


===
fn block_text(block: &BlockBox) -> String {
    block
        .lines
        .iter()
        .map(|l| line_to_text(l))
        .filter(|s| !s.is_empty())
        .collect::<Vec<_>>()
        .join("\n")
        .trim()
        .to_string()
}

fn render_pages_to_md(pages: Vec<PageBox>) -> String {
    let mut out = String::new();

    for (pi, page) in pages.iter().enumerate() {
        let mut blocks = page.blocks.clone();
        blocks.sort_by(|a, b| a.y_min.partial_cmp(&b.y_min).unwrap_or(std::cmp::Ordering::Equal));

        // body_left = median x_min bloków “normalnych”
        let mut xmins: Vec<f32> = blocks.iter().map(|b| b.x_min).collect();
        xmins.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
        let body_left = xmins.get(xmins.len() / 2).copied().unwrap_or(0.0);

        for block in &blocks {
            let text = block_text(block);
            if text.is_empty() {
                continue;
            }

            let indent = block.x_min - body_left;

            // prosta heurystyka na nagłówek vs note:
            // - heading: blisko body_left i krótki
            // - note: wyraźnie w prawo
            let is_note = indent >= 30.0;
            let is_heading = indent.abs() <= 10.0 && text.len() <= 80 && block.lines.len() <= 2;

            if is_heading {
                out.push_str("## ");
                out.push_str(text.trim());
                out.push_str("\n\n");
            } else if is_note {
                out.push_str("> [!NOTE]\n");
                for ln in text.lines() {
                    let ln = ln.trim();
                    if !ln.is_empty() {
                        out.push_str("> ");
                        out.push_str(ln);
                        out.push('\n');
                    }
                }
                out.push('\n');
            } else {
                out.push_str(text.trim());
                out.push_str("\n\n");
            }
        }

        // separator strony (opcjonalny)
        if pi + 1 < pages.len() {
            out.push_str("\n---\n\n");
        }
    }

    out
}

===

pub fn bbox_layout_xhtml_to_md(xhtml: &str) -> Result<String> {
    let pages = parse_bbox_layout_pages(xhtml)?;
    Ok(render_pages_to_md(pages))
}

  
