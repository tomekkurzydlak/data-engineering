/// Pobiera listę plików i ich steps dla trybu batch.
/// Format z DB:
/// [
///   { "file_id": "...", "gcs_file_uri": "...", "processes": [ {...}, {...} ] },
///   { "file_id": "...", "gcs_file_uri": "...", "processes": [ {...}, {...} ] },
///   ...
/// ]
async fn get_batch_steps(
    &self,
    file_watcher_id: i64,
) -> Result<HashMap<String, (String, Vec<ProcessStep>)>> {

    let q = r#"select mda_14_proc_unstruct.get_payload_for_dispatcher_batch($1)"#;

    // ------------------------------
    // 1. Pobieramy json z DB
    // ------------------------------
    let row = self
        .client
        .query_one(q, &[&file_watcher_id])
        .await
        .with_context(|| {
            format!(
                "{code}: Błąd wykonania get_payload_for_dispatcher_batch({file_watcher_id})",
                code = StepErrorCode::DbFetch.as_str()
            )
        })?;

    let json: JsonValue = row.get(0);

    // ------------------------------
    // 2. NULL → brak batcha
    // ------------------------------
    if json.is_null() {
        warn!(
            code = StepErrorCode::NullJson.as_str(),
            "get_batch_steps: DB zwróciła NULL — brak kroków"
        );
        return Ok(HashMap::new());
    }

    // ------------------------------
    // 3. JSON musi być tablicą N elementów
    // ------------------------------
    let arr = match json.as_array() {
        Some(a) if !a.is_empty() => a,
        _ => {
            warn!(
                code = StepErrorCode::EmptyProcesses.as_str(),
                "get_batch_steps: JSON pusty lub nie będący tablicą"
            );
            return Ok(HashMap::new());
        }
    };

    // ------------------------------
    // 4. Parsujemy każde entry jako FileProcess
    // ------------------------------
    let mut map: HashMap<String, (String, Vec<ProcessStep>)> = HashMap::new();

    for (idx, val) in arr.iter().enumerate() {
        // pierwsza warstwa: błąd w JSON obiektu FileProcess
        let fp: FileProcess = match serde_json::from_value(val.clone()) {
            Ok(f) => f,
            Err(e) => {
                error!(
                    idx,
                    error=?e,
                    code = StepErrorCode::JsonParse.as_str(),
                    "get_batch_steps: nie mogę sparsować FileProcess — pomijam element"
                );
                continue;
            }
        };

        // brak processes
        if fp.processes.is_empty() {
            error!(
                idx,
                file_id = %fp.file_id,
                code = StepErrorCode::EmptyProcesses.as_str(),
                "get_batch_steps: plik ma pustą listę processes — pomijam"
            );
            continue;
        }

        // sortujemy processes
        let mut steps = fp.processes;
        steps.sort_by_key(|s| s.exec_process_seq);

        map.insert(fp.file_id, (fp.gcs_file_uri, steps));
    }

    if map.is_empty() {
        warn!(
            code = StepErrorCode::EmptyProcesses.as_str(),
            "get_batch_steps: żadnego poprawnego elementu — zwracam pustą mapę"
        );
    }

    Ok(map)
}
