payload
==
// ---------------------------------------------------------------------------------
// DYNAMIC + BATCH  (payload = prefiks pipeline, DB = kontynuacja)
// ---------------------------------------------------------------------------------
async fn run_dynamic_wfl_batch_jobs(&self, files: Vec<FileProcess>) -> Result<()> {
    let db = self
        .db
        .as_ref()
        .cloned()
        .ok_or_else(|| anyhow::anyhow!("Brak połączenia z DB dla dynamicznego workflow"))?;

    let fw_id = self
        .cfg
        .file_watcher_id
        .ok_or_else(|| anyhow!("dynamic+batch wymaga parametru --file-watcher-id"))?;

    // =========================================================================
    // 1️⃣ KROKI Z PAYLOADU — wykonujemy WSZYSTKIE, w kolejności seq
    // =========================================================================

    // seq -> [(file_id, uri, step)]
    let mut payload_steps: HashMap<u32, Vec<(String, String, ProcessStep)>> = HashMap::new();

    // ostatni wykonany seq per file (ustawiany na podstawie payloadu)
    let mut last_seq: HashMap<String, u32> = HashMap::new();

    for f in &files {
        if f.processes.is_empty() {
            warn!(
                file_id = %f.file_id,
                "DYNAMIC+BATCH: payload zawiera plik bez kroków — pomijam"
            );
            continue;
        }

        let mut steps = f.processes.clone();
        steps.sort_by_key(|s| s.exec_process_seq);

        for step in &steps {
            payload_steps
                .entry(step.exec_process_seq)
                .or_default()
                .push((
                    f.file_id.clone(),
                    f.gcs_file_uri.clone(),
                    step.clone(),
                ));
        }

        if let Some(max_step) = steps.last() {
            last_seq.insert(f.file_id.clone(), max_step.exec_process_seq);
        }
    }

    if payload_steps.is_empty() {
        warn!("DYNAMIC+BATCH: brak kroków w payloadzie — nic do wykonania");
        return Ok(());
    }

    let mut payload_seqs: Vec<u32> = payload_steps.keys().cloned().collect();
    payload_seqs.sort_unstable();

    info!(
        seqs = ?payload_seqs,
        "DYNAMIC+BATCH: start — wykonuję kroki z payloadu"
    );

    for seq in payload_seqs {
        let batch = &payload_steps[&seq];
        let process_cd = batch[0].2.process_cd.clone();

        info!(
            seq,
            count = batch.len(),
            %process_cd,
            "DYNAMIC+BATCH: batch kroków z payloadu"
        );

        if let Some(db) = &self.db {
            let file_watcher_id = self.cfg.file_watcher_id.unwrap_or(0);
            let tech_insert_id = self.cfg.tech_insert_id.unwrap_or(0);

            let pid = db
                .init_batch_session(&process_cd, file_watcher_id, tech_insert_id)
                .await
                .context("DYNAMIC+BATCH: błąd start_process_watcher_f (payload)")?;

            let result = self.run_batch_for_steps(batch).await;

            let tech_update_id = self.cfg.tech_insert_id.unwrap_or(0);
            let (status_cd, error_msg) = match &result {
                Ok(_) => ("COMPLETED", "".to_string()),
                Err(e) => ("ERROR", e.to_string()),
            };

            if let Err(e) = db
                .end_session(pid, status_cd, &error_msg, tech_update_id)
                .await
            {
                error!(
                    error=?e,
                    %pid,
                    %process_cd,
                    "DYNAMIC+BATCH: błąd finish_process_f (payload)"
                );
            }

            result?;
        } else {
            self.run_batch_for_steps(batch).await?;
        }
    }

    // =========================================================================
    // 2️⃣ KOLEJNE KROKI Z DB — kontynuacja pipeline
    // =========================================================================

    let full_map = db.get_batch_steps(fw_id).await?;
    if full_map.is_empty() {
        info!("DYNAMIC+BATCH: brak kolejnych kroków w DB — pipeline zakończony");
        return Ok(());
    }

    // file_id -> (uri, VecDeque<ProcessStep>)
    let mut steps_map: HashMap<String, (String, VecDeque<ProcessStep>)> = HashMap::new();

    for (file_id, (uri, steps_vec)) in full_map.into_iter() {
        let dq: VecDeque<ProcessStep> = steps_vec.into();
        steps_map.insert(file_id.clone(), (uri, dq));
    }

    // =========================================================================
    // 3️⃣ KOLEJNE BATCH-E Z DB (jak dotychczas)
    // =========================================================================
    loop {
        let mut batch: Vec<(String, String, ProcessStep)> = Vec::new();

        for (file_id, (uri, dq)) in steps_map.iter_mut() {
            let prev_seq = *last_seq.get(file_id).unwrap_or(&0);

            if let Some(next_step) = dq.pop_front() {
                if next_step.exec_process_seq > prev_seq {
                    last_seq.insert(file_id.clone(), next_step.exec_process_seq);
                    batch.push((file_id.clone(), uri.clone(), next_step));
                } else {
                    warn!(
                        %file_id,
                        prev_seq,
                        next = next_step.exec_process_seq,
                        "DYNAMIC+BATCH: krok z DB ma seq <= poprzedni — pomijam"
                    );
                }
            }
        }

        // usuń puste kolejki
        steps_map.retain(|_, (_, dq)| !dq.is_empty());

        if batch.is_empty() {
            info!("DYNAMIC+BATCH: brak kolejnych kroków — pipeline zakończony");
            break;
        }

        let process_cd = batch[0].2.process_cd.clone();
        let seq = batch[0].2.exec_process_seq;

        info!(
            count = batch.len(),
            %process_cd,
            seq,
            "DYNAMIC+BATCH: batch kolejnych kroków z DB"
        );

        if let Some(db) = &self.db {
            let file_watcher_id = self.cfg.file_watcher_id.unwrap_or(0);
            let tech_insert_id = self.cfg.tech_insert_id.unwrap_or(0);

            let pid = db
                .init_session(&process_cd, file_watcher_id, tech_insert_id)
                .await
                .context("DYNAMIC+BATCH: błąd start_process_f (DB)")?;

            let result = self.run_batch_for_steps(&batch).await;

            let tech_update_id = self
                .cfg
                .tech_insert_id
                .unwrap_or(0);

            let (status_cd, error_msg) = match &result {
                Ok(_) => ("COMPLETED", "".to_string()),
                Err(e) => ("ERROR", e.to_string()),
            };

            if let Err(e) = db
                .end_session(pid, status_cd, &error_msg, tech_update_id)
                .await
            {
                error!(error=?e, %pid, "DYNAMIC+BATCH: błąd finish_process_f (DB)");
            }

            result?;
        } else {
            self.run_batch_for_steps(&batch).await?;
        }
    }

    Ok(())
}

==
fm.type_specific_metadata = Some(payload);

// 1) wytwórz markdown (albo z pdftotext, albo z docling)
let content_md: String = match args.pdf2md_engine {
    Pdf2MdEngine::Pdf2text => {
        let pdf2text_args = &["-layout", path_str, "-"];
        run_command_with_args("pdftotext", pdf2text_args)?
    }
    Pdf2MdEngine::Docling => {
        run_docling_md(path_str)?
    }
};

// 2) reszta jak wcześniej: hash + zapis do GCS + zwrot URI
let enriched_data = EnrichedFile {
    uri: gcs_data_uri.clone(),
    format: "markdown".to_owned(),
    hash_sha256: sha256_content(content_md.as_bytes())?,
};
fm.enriched_file = Some(enriched_data);

let bs = bytes::Bytes::from_owner(content_md.into_bytes());
write_to_gcs(&gcs_data_uri, bs).await?;
Ok(gcs_data_uri)



==
pub fn run_docling_md(pdf_path: &str) -> Result<String> {
    // Docling zapisuje wynik do katalogu, więc robimy tmpdir per plik
    let out_dir = PathBuf::from(format!("/tmp/docling_{}", Uuid::new_v4()));
    fs::create_dir_all(&out_dir)?;

    // Default: bez OCR (wydajność). Jeśli masz skany – później dorobisz przełącznik.
    let args = [
        "--to", "md",
        "--output", out_dir.to_str().ok_or_else(|| anyhow!("Bad out_dir"))?,
        "--no-ocr",
        "--tables",
        pdf_path,
    ];

    let output = std::process::Command::new("docling")
        .args(&args)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .output()
        .map_err(|e| anyhow!("Failed to run docling binary: {e}"))?;

    if !output.status.success() {
        let err = String::from_utf8_lossy(&output.stderr).to_string();
        return Err(anyhow!("docling failed: {}", err));
    }

    // Znajdź wygenerowany plik .md
    let mut md_files: Vec<PathBuf> = fs::read_dir(&out_dir)?
        .filter_map(|e| e.ok())
        .map(|e| e.path())
        .filter(|p| p.extension().map(|x| x == "md").unwrap_or(false))
        .collect();

    md_files.sort();

    let md_path = md_files
        .pop()
        .ok_or_else(|| anyhow!("docling finished but no .md file found in {}", out_dir.display()))?;

    let md = fs::read_to_string(&md_path)?;

    // Sprzątanie (best effort)
    let _ = fs::remove_dir_all(&out_dir);

    Ok(md)
}


===
use std::error::Error;
use std::ffi::OsStr;
use std::fs;
use std::path::Path;

const DEFAULT_INPUT_DIR: &str = "/Users/tomek/IdeaProjects/test-pdfium/testdata/pdfs";
const DEFAULT_OUTPUT_DIR: &str = "out";

fn main() -> Result<(), Box<dyn Error>> {
    let mut args = std::env::args().skip(1);
    let input_dir = args.next().unwrap_or_else(|| DEFAULT_INPUT_DIR.to_string());
    let output_dir = args.next().unwrap_or_else(|| DEFAULT_OUTPUT_DIR.to_string());

    fs::create_dir_all(&output_dir)?;

    for entry in fs::read_dir(&input_dir)? {
        let entry = entry?;
        let path = entry.path();
        if !is_pdf(&path) {
            continue;
        }

        println!("Converting: {}", path.display());
        let markdown = markdownify::convert(path.as_path())?;

        let stem = path
            .file_stem()
            .and_then(OsStr::to_str)
            .ok_or("Failed to read file stem")?;
        let out_path = Path::new(&output_dir).join(format!("{stem}.md"));
        fs::write(&out_path, markdown)?;
        println!("Wrote: {}", out_path.display());
    }

    Ok(())
}

fn is_pdf(path: &Path) -> bool {
    match path.extension().and_then(OsStr::to_str) {
        Some(ext) => ext.eq_ignore_ascii_case("pdf"),
        None => false,
    }
}


==

[package]
name = "markdownify-test"
version = "0.1.0"
edition = "2024"

[dependencies]
markdownify = "0.2.1"
