pub fn run_docling_md(pdf_path: &str) -> Result<String> {
    // Docling zapisuje wynik do katalogu, więc robimy tmpdir per plik
    let out_dir = PathBuf::from(format!("/tmp/docling_{}", Uuid::new_v4()));
    fs::create_dir_all(&out_dir)?;

    // Default: bez OCR (wydajność). Jeśli masz skany – później dorobisz przełącznik.
    let args = [
        "--to", "md",
        "--output", out_dir.to_str().ok_or_else(|| anyhow!("Bad out_dir"))?,
        "--no-ocr",
        "--tables",
        pdf_path,
    ];

    let output = std::process::Command::new("docling")
        .args(&args)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .output()
        .map_err(|e| anyhow!("Failed to run docling binary: {e}"))?;

    if !output.status.success() {
        let err = String::from_utf8_lossy(&output.stderr).to_string();
        return Err(anyhow!("docling failed: {}", err));
    }

    // Znajdź wygenerowany plik .md
    let mut md_files: Vec<PathBuf> = fs::read_dir(&out_dir)?
        .filter_map(|e| e.ok())
        .map(|e| e.path())
        .filter(|p| p.extension().map(|x| x == "md").unwrap_or(false))
        .collect();

    md_files.sort();

    let md_path = md_files
        .pop()
        .ok_or_else(|| anyhow!("docling finished but no .md file found in {}", out_dir.display()))?;

    let md = fs::read_to_string(&md_path)?;

    // Sprzątanie (best effort)
    let _ = fs::remove_dir_all(&out_dir);

    Ok(md)
}


===
use std::error::Error;
use std::ffi::OsStr;
use std::fs;
use std::path::Path;

const DEFAULT_INPUT_DIR: &str = "/Users/tomek/IdeaProjects/test-pdfium/testdata/pdfs";
const DEFAULT_OUTPUT_DIR: &str = "out";

fn main() -> Result<(), Box<dyn Error>> {
    let mut args = std::env::args().skip(1);
    let input_dir = args.next().unwrap_or_else(|| DEFAULT_INPUT_DIR.to_string());
    let output_dir = args.next().unwrap_or_else(|| DEFAULT_OUTPUT_DIR.to_string());

    fs::create_dir_all(&output_dir)?;

    for entry in fs::read_dir(&input_dir)? {
        let entry = entry?;
        let path = entry.path();
        if !is_pdf(&path) {
            continue;
        }

        println!("Converting: {}", path.display());
        let markdown = markdownify::convert(path.as_path())?;

        let stem = path
            .file_stem()
            .and_then(OsStr::to_str)
            .ok_or("Failed to read file stem")?;
        let out_path = Path::new(&output_dir).join(format!("{stem}.md"));
        fs::write(&out_path, markdown)?;
        println!("Wrote: {}", out_path.display());
    }

    Ok(())
}

fn is_pdf(path: &Path) -> bool {
    match path.extension().and_then(OsStr::to_str) {
        Some(ext) => ext.eq_ignore_ascii_case("pdf"),
        None => false,
    }
}


==

[package]
name = "markdownify-test"
version = "0.1.0"
edition = "2024"

[dependencies]
markdownify = "0.2.1"
