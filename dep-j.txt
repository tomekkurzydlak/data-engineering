/// Tworzy lub aktualizuje Cloud Run Job (pełny deploy)
pub async fn deploy_job(
    &self,
    job_name: &str,
    image: &str,
    envs: &HashMap<String, String>,
    service_account: &str,
    sql_instance: Option<&str>,
) -> Result<()> {
    let token = self.get_token().await?;
    let url = format!("{}/jobs?jobId={}", self.jobs_base(), job_name);

    let env_json: Vec<_> = envs.iter()
        .map(|(k,v)| serde_json::json!({ "name": k, "value": v }))
        .collect();

    let mut template = serde_json::json!({
        "template": {
            "template": {
                "serviceAccount": service_account,
                "containers": [{
                    "image": image,
                    "env": env_json
                }]
            }
        }
    });

    if let Some(sql) = sql_instance {
        template["template"]["template"]["volumes"] = serde_json::json!([{
            "name": "cloudsql",
            "cloudSqlInstance": { "instances": [ sql ] }
        }]);
    }

    info!(%job_name, "Tworzę/aktualizuję Cloud Run Job...");
    let res = self.client
        .post(&url)
        .bearer_auth(&token)
        .header("Content-Type", "application/json")
        .json(&template)
        .send()
        .await
        .context("błąd POST /jobs")?;

    let status = res.status();
    if status.is_success() {
        info!(%job_name, "Cloud Run Job zdeployowany");
        Ok(())
    } else {
        let txt = res.text().await.unwrap_or_default();
        anyhow::bail!("Deploy job failed ({}): {}", status, txt);
    }
}
